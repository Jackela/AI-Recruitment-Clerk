import { Injectable, Logger } from '@nestjs/common';\nimport { CacheService } from '../cache/cache.service';\nimport { NotificationService } from './notification.service';\nimport { CollaborationService } from './collaboration.service';\n\nexport interface Decision {\n  id: string;\n  title: string;\n  description: string;\n  type: 'vote' | 'consensus' | 'approval' | 'ranking' | 'prioritization' | 'binary';\n  status: 'draft' | 'active' | 'completed' | 'cancelled' | 'expired';\n  createdBy: string;\n  createdByName: string;\n  roomId: string;\n  contextId: string;\n  contextType: 'candidate' | 'job' | 'policy' | 'budget' | 'feature' | 'strategy';\n  options: DecisionOption[];\n  participants: DecisionParticipant[];\n  settings: DecisionSettings;\n  timeline: DecisionEvent[];\n  result?: DecisionResult;\n  createdAt: Date;\n  startsAt?: Date;\n  deadline?: Date;\n  completedAt?: Date;\n  metadata: {\n    tags: string[];\n    priority: 'low' | 'medium' | 'high' | 'urgent';\n    confidential: boolean;\n    stakeholders: string[];\n    budget?: number;\n    expectedImpact?: 'low' | 'medium' | 'high';\n  };\n}\n\nexport interface DecisionOption {\n  id: string;\n  text: string;\n  description?: string;\n  category?: string;\n  pros: string[];\n  cons: string[];\n  impact?: {\n    financial?: number;\n    timeline?: number; // in days\n    resources?: string[];\n    risk?: 'low' | 'medium' | 'high';\n  };\n  votes: Vote[];\n  score: number;\n  ranking?: number;\n  metadata?: Record<string, any>;\n}\n\nexport interface DecisionParticipant {\n  userId: string;\n  username: string;\n  email?: string;\n  role: 'decision_maker' | 'advisor' | 'stakeholder' | 'observer';\n  department?: string;\n  weight: number; // Voting weight\n  required: boolean; // Required to participate\n  invitedAt: Date;\n  joinedAt?: Date;\n  lastActivity?: Date;\n  hasVoted: boolean;\n  delegatedTo?: string; // User ID if vote is delegated\n}\n\nexport interface Vote {\n  id: string;\n  userId: string;\n  username: string;\n  optionId: string;\n  value: number | string | boolean; // Depends on decision type\n  confidence: number; // 1-10 scale\n  comment?: string;\n  reasoning?: string;\n  timestamp: Date;\n  isAnonymous: boolean;\n  weight: number;\n  delegatedFrom?: string; // Original voter if delegated\n}\n\nexport interface DecisionSettings {\n  anonymous: boolean;\n  allowComments: boolean;\n  requireJustification: boolean;\n  allowChangeVote: boolean;\n  allowDelegation: boolean;\n  weightedVoting: boolean;\n  minimumParticipation: number; // percentage\n  quorum?: number; // minimum number of votes\n  consensusThreshold?: number; // percentage for consensus\n  autoComplete: boolean;\n  autoCompleteRules: {\n    onQuorum: boolean;\n    onDeadline: boolean;\n    onUnanimous: boolean;\n    onMajority: boolean;\n  };\n  escalation?: {\n    enabled: boolean;\n    timeoutHours: number;\n    escalateTo: string[]; // User IDs\n  };\n}\n\nexport interface DecisionEvent {\n  id: string;\n  type: 'created' | 'started' | 'vote_cast' | 'vote_changed' | 'comment_added' | 'participant_added' | 'deadline_extended' | 'completed' | 'cancelled';\n  userId: string;\n  username: string;\n  description: string;\n  metadata?: Record<string, any>;\n  timestamp: Date;\n}\n\nexport interface DecisionResult {\n  winningOption?: string;\n  winningOptions?: string[]; // For multi-select decisions\n  totalVotes: number;\n  participationRate: number;\n  consensusReached: boolean;\n  confidenceScore: number; // Average confidence\n  breakdown: {\n    [optionId: string]: {\n      votes: number;\n      percentage: number;\n      weightedScore: number;\n      averageConfidence: number;\n    };\n  };\n  analysis: {\n    strongSupport: string[]; // Option IDs with >70% support\n    weakSupport: string[]; // Option IDs with 30-70% support\n    opposition: string[]; // Option IDs with <30% support\n    polarization: number; // 0-1 scale\n    unanimity: boolean;\n  };\n  recommendations?: string[];\n  nextSteps?: string[];\n}\n\nexport interface DecisionComment {\n  id: string;\n  decisionId: string;\n  optionId?: string; // Comment on specific option\n  content: string;\n  authorId: string;\n  authorName: string;\n  parentId?: string; // For threaded comments\n  type: 'general' | 'support' | 'concern' | 'question' | 'suggestion';\n  reactions: CommentReaction[];\n  mentions: string[];\n  timestamp: Date;\n  isAnonymous: boolean;\n}\n\nexport interface CommentReaction {\n  emoji: string;\n  userId: string;\n  timestamp: Date;\n}\n\nexport interface DecisionTemplate {\n  id: string;\n  name: string;\n  description: string;\n  type: Decision['type'];\n  category: 'hiring' | 'budget' | 'strategy' | 'operations' | 'policy';\n  defaultSettings: DecisionSettings;\n  optionTemplate: {\n    fields: string[];\n    prosConsRequired: boolean;\n    impactRequired: boolean;\n  };\n  participantRoles: {\n    role: DecisionParticipant['role'];\n    defaultWeight: number;\n    permissions: string[];\n  }[];\n  timeline: {\n    preparation: number; // hours\n    voting: number; // hours\n    review: number; // hours\n  };\n  createdBy: string;\n  createdAt: Date;\n  usageCount: number;\n}\n\nexport interface DecisionAnalytics {\n  decisionId: string;\n  metrics: {\n    timeToDecision: number; // hours\n    participationRate: number;\n    consensusScore: number;\n    changeMindRate: number; // % of participants who changed votes\n    commentEngagement: number;\n    delegationRate: number;\n  };\n  participantAnalysis: {\n    userId: string;\n    engagement: number; // 0-1 scale\n    influence: number; // Based on how often others align with their votes\n    consistency: number; // How consistent their voting patterns are\n    responseTime: number; // Average time to vote\n  }[];\n  outcomeTracking?: {\n    implemented: boolean;\n    implementationDate?: Date;\n    actualOutcome?: string;\n    successRating?: number; // 1-10\n    lessonsLearned?: string[];\n  };\n}\n\n@Injectable()\nexport class DecisionMakingService {\n  private readonly logger = new Logger(DecisionMakingService.name);\n  private readonly DECISION_TTL = 90 * 24 * 60 * 60 * 1000; // 90 days\n  private readonly DEFAULT_VOTE_WEIGHT = 1;\n  private readonly CONSENSUS_THRESHOLD = 0.8; // 80%\n\n  constructor(\n    private readonly cacheService: CacheService,\n    private readonly notificationService: NotificationService,\n    private readonly collaborationService: CollaborationService\n  ) {\n    this.startDecisionMonitor();\n  }\n\n  /**\n   * Create a new decision\n   */\n  async createDecision(decisionData: Partial<Decision>): Promise<Decision> {\n    const decision: Decision = {\n      id: this.generateId(),\n      title: decisionData.title || 'Untitled Decision',\n      description: decisionData.description || '',\n      type: decisionData.type || 'vote',\n      status: 'draft',\n      createdBy: decisionData.createdBy || '',\n      createdByName: decisionData.createdByName || '',\n      roomId: decisionData.roomId || '',\n      contextId: decisionData.contextId || '',\n      contextType: decisionData.contextType || 'candidate',\n      options: decisionData.options || [],\n      participants: decisionData.participants || [],\n      settings: {\n        anonymous: false,\n        allowComments: true,\n        requireJustification: false,\n        allowChangeVote: true,\n        allowDelegation: false,\n        weightedVoting: false,\n        minimumParticipation: 50,\n        autoComplete: true,\n        autoCompleteRules: {\n          onQuorum: true,\n          onDeadline: true,\n          onUnanimous: true,\n          onMajority: false,\n        },\n        ...decisionData.settings,\n      },\n      timeline: [\n        {\n          id: this.generateId(),\n          type: 'created',\n          userId: decisionData.createdBy || '',\n          username: decisionData.createdByName || '',\n          description: 'Decision created',\n          timestamp: new Date(),\n        }\n      ],\n      createdAt: new Date(),\n      startsAt: decisionData.startsAt,\n      deadline: decisionData.deadline,\n      metadata: {\n        tags: [],\n        priority: 'medium',\n        confidential: false,\n        stakeholders: [],\n        ...decisionData.metadata,\n      },\n    };\n\n    await this.saveDecision(decision);\n    \n    // Add to room's decisions list\n    if (decision.roomId) {\n      await this.addDecisionToRoom(decision.roomId, decision.id);\n    }\n\n    this.logger.log(`Decision created: ${decision.id} - ${decision.title}`);\n    return decision;\n  }\n\n  /**\n   * Start a decision (make it active)\n   */\n  async startDecision(decisionId: string, userId: string): Promise<Decision | null> {\n    const decision = await this.getDecision(decisionId);\n    if (!decision) return null;\n\n    if (decision.createdBy !== userId) {\n      throw new Error('Only the decision creator can start the decision');\n    }\n\n    if (decision.status !== 'draft') {\n      throw new Error('Decision can only be started from draft status');\n    }\n\n    decision.status = 'active';\n    decision.startsAt = new Date();\n    \n    // Set default deadline if not set (24 hours from now)\n    if (!decision.deadline) {\n      decision.deadline = new Date(Date.now() + 24 * 60 * 60 * 1000);\n    }\n\n    // Add timeline event\n    decision.timeline.push({\n      id: this.generateId(),\n      type: 'started',\n      userId,\n      username: decision.createdByName,\n      description: 'Decision started and opened for voting',\n      timestamp: new Date(),\n    });\n\n    await this.saveDecision(decision);\n    \n    // Notify participants\n    await this.notifyParticipants(decision, 'decision_started');\n\n    this.logger.log(`Decision started: ${decisionId}`);\n    return decision;\n  }\n\n  /**\n   * Cast a vote\n   */\n  async castVote(\n    decisionId: string, \n    userId: string, \n    optionId: string, \n    value: any, \n    voteData: {\n      confidence?: number;\n      comment?: string;\n      reasoning?: string;\n      isAnonymous?: boolean;\n    } = {}\n  ): Promise<boolean> {\n    const decision = await this.getDecision(decisionId);\n    if (!decision) return false;\n\n    if (decision.status !== 'active') {\n      throw new Error('Decision is not active for voting');\n    }\n\n    if (decision.deadline && new Date() > decision.deadline) {\n      throw new Error('Voting deadline has passed');\n    }\n\n    const participant = decision.participants.find(p => p.userId === userId);\n    if (!participant) {\n      throw new Error('User is not a participant in this decision');\n    }\n\n    const option = decision.options.find(o => o.id === optionId);\n    if (!option) {\n      throw new Error('Invalid option ID');\n    }\n\n    // Remove existing vote if changing vote is allowed\n    if (decision.settings.allowChangeVote) {\n      option.votes = option.votes.filter(v => v.userId !== userId);\n    } else if (option.votes.some(v => v.userId === userId)) {\n      throw new Error('Vote already cast and changes are not allowed');\n    }\n\n    // Validate vote value based on decision type\n    const validatedValue = this.validateVoteValue(decision.type, value);\n    if (validatedValue === null) {\n      throw new Error('Invalid vote value for this decision type');\n    }\n\n    // Create vote\n    const vote: Vote = {\n      id: this.generateId(),\n      userId,\n      username: participant.username,\n      optionId,\n      value: validatedValue,\n      confidence: voteData.confidence || 5,\n      comment: voteData.comment,\n      reasoning: voteData.reasoning,\n      timestamp: new Date(),\n      isAnonymous: voteData.isAnonymous || decision.settings.anonymous,\n      weight: decision.settings.weightedVoting ? participant.weight : this.DEFAULT_VOTE_WEIGHT,\n    };\n\n    // Validate justification requirement\n    if (decision.settings.requireJustification && !vote.reasoning) {\n      throw new Error('Justification is required for this decision');\n    }\n\n    option.votes.push(vote);\n    participant.hasVoted = true;\n    participant.lastActivity = new Date();\n\n    // Recalculate scores\n    this.calculateOptionScores(decision);\n\n    // Add timeline event\n    decision.timeline.push({\n      id: this.generateId(),\n      type: participant.hasVoted ? 'vote_changed' : 'vote_cast',\n      userId,\n      username: vote.isAnonymous ? 'Anonymous' : participant.username,\n      description: `Vote ${participant.hasVoted ? 'changed' : 'cast'} for \"${option.text}\"`,\n      metadata: { optionId, confidence: vote.confidence },\n      timestamp: new Date(),\n    });\n\n    await this.saveDecision(decision);\n\n    // Check if decision should auto-complete\n    await this.checkAutoCompletion(decision);\n\n    // Notify about vote (if not anonymous)\n    if (!vote.isAnonymous) {\n      await this.notifyVoteCast(decision, vote, option);\n    }\n\n    this.logger.log(`Vote cast on decision ${decisionId} by user ${userId}`);\n    return true;\n  }\n\n  /**\n   * Add comment to decision\n   */\n  async addComment(\n    decisionId: string,\n    commentData: Omit<DecisionComment, 'id' | 'timestamp' | 'reactions'>\n  ): Promise<DecisionComment> {\n    const decision = await this.getDecision(decisionId);\n    if (!decision) {\n      throw new Error('Decision not found');\n    }\n\n    if (!decision.settings.allowComments) {\n      throw new Error('Comments are not allowed for this decision');\n    }\n\n    const comment: DecisionComment = {\n      ...commentData,\n      id: this.generateId(),\n      timestamp: new Date(),\n      reactions: [],\n    };\n\n    const commentsKey = `decision:${decisionId}:comments`;\n    const existingComments = await this.cacheService.get<DecisionComment[]>(commentsKey) || [];\n    existingComments.push(comment);\n    \n    await this.cacheService.set(commentsKey, existingComments, this.DECISION_TTL);\n\n    // Add timeline event\n    decision.timeline.push({\n      id: this.generateId(),\n      type: 'comment_added',\n      userId: commentData.authorId,\n      username: comment.isAnonymous ? 'Anonymous' : commentData.authorName,\n      description: `Comment added: \"${comment.content.substring(0, 50)}...\"`,\n      timestamp: new Date(),\n    });\n\n    await this.saveDecision(decision);\n\n    // Notify mentioned users\n    if (comment.mentions.length > 0) {\n      await this.notifyMentionedUsers(decision, comment);\n    }\n\n    this.logger.log(`Comment added to decision ${decisionId}`);\n    return comment;\n  }\n\n  /**\n   * Complete decision manually\n   */\n  async completeDecision(decisionId: string, userId: string): Promise<Decision | null> {\n    const decision = await this.getDecision(decisionId);\n    if (!decision) return null;\n\n    if (decision.createdBy !== userId && !this.hasAdminPermission(decision, userId)) {\n      throw new Error('Insufficient permissions to complete decision');\n    }\n\n    if (decision.status !== 'active') {\n      throw new Error('Only active decisions can be completed');\n    }\n\n    decision.status = 'completed';\n    decision.completedAt = new Date();\n    decision.result = this.calculateDecisionResult(decision);\n\n    // Add timeline event\n    decision.timeline.push({\n      id: this.generateId(),\n      type: 'completed',\n      userId,\n      username: decision.participants.find(p => p.userId === userId)?.username || 'System',\n      description: 'Decision manually completed',\n      timestamp: new Date(),\n    });\n\n    await this.saveDecision(decision);\n\n    // Notify participants of completion\n    await this.notifyParticipants(decision, 'decision_completed');\n\n    // Send results to collaboration room\n    if (decision.roomId) {\n      await this.collaborationService.sendMessage(decision.roomId, {\n        type: 'decision_made',\n        content: `Decision \"${decision.title}\" has been completed. Winner: ${this.getWinningOptionText(decision)}`,\n        authorId: 'system',\n        authorName: 'Decision System',\n        contextData: {\n          decisionId: decision.id,\n        },\n      });\n    }\n\n    this.logger.log(`Decision completed: ${decisionId}`);\n    return decision;\n  }\n\n  /**\n   * Get decision by ID\n   */\n  async getDecision(decisionId: string): Promise<Decision | null> {\n    return await this.cacheService.get<Decision>(`decision:${decisionId}`);\n  }\n\n  /**\n   * Get decision comments\n   */\n  async getDecisionComments(decisionId: string): Promise<DecisionComment[]> {\n    const commentsKey = `decision:${decisionId}:comments`;\n    return await this.cacheService.get<DecisionComment[]>(commentsKey) || [];\n  }\n\n  /**\n   * Get decision analytics\n   */\n  async getDecisionAnalytics(decisionId: string): Promise<DecisionAnalytics | null> {\n    const decision = await this.getDecision(decisionId);\n    if (!decision) return null;\n\n    const analytics: DecisionAnalytics = {\n      decisionId,\n      metrics: this.calculateDecisionMetrics(decision),\n      participantAnalysis: this.analyzeParticipants(decision),\n    };\n\n    return analytics;\n  }\n\n  /**\n   * Create decision from template\n   */\n  async createFromTemplate(\n    templateId: string, \n    overrides: Partial<Decision>,\n    userId: string\n  ): Promise<Decision> {\n    const template = await this.getTemplate(templateId);\n    if (!template) {\n      throw new Error('Template not found');\n    }\n\n    const decision = await this.createDecision({\n      ...overrides,\n      type: template.type,\n      settings: {\n        ...template.defaultSettings,\n        ...overrides.settings,\n      },\n      createdBy: userId,\n    });\n\n    // Update template usage count\n    template.usageCount++;\n    await this.saveTemplate(template);\n\n    return decision;\n  }\n\n  /**\n   * Export decision results\n   */\n  async exportResults(\n    decisionId: string, \n    format: 'json' | 'csv' | 'pdf',\n    includeComments: boolean = false\n  ): Promise<{ content: string; mimeType: string }> {\n    const decision = await this.getDecision(decisionId);\n    if (!decision) {\n      throw new Error('Decision not found');\n    }\n\n    let content = '';\n    let mimeType = '';\n\n    switch (format) {\n      case 'json':\n        const exportData = {\n          decision,\n          comments: includeComments ? await this.getDecisionComments(decisionId) : undefined,\n          analytics: await this.getDecisionAnalytics(decisionId),\n        };\n        content = JSON.stringify(exportData, null, 2);\n        mimeType = 'application/json';\n        break;\n        \n      case 'csv':\n        content = this.convertToCSV(decision);\n        mimeType = 'text/csv';\n        break;\n        \n      case 'pdf':\n        content = await this.convertToPDF(decision, includeComments);\n        mimeType = 'application/pdf';\n        break;\n    }\n\n    return { content, mimeType };\n  }\n\n  /**\n   * Private helper methods\n   */\n  private startDecisionMonitor(): void {\n    // Check for expired decisions every minute\n    setInterval(async () => {\n      await this.checkExpiredDecisions();\n    }, 60000);\n  }\n\n  private async checkExpiredDecisions(): Promise<void> {\n    // Implementation would scan for expired decisions\n    // For now, this is a placeholder\n    this.logger.debug('Checking for expired decisions...');\n  }\n\n  private async checkAutoCompletion(decision: Decision): Promise<void> {\n    if (!decision.settings.autoComplete) return;\n\n    const rules = decision.settings.autoCompleteRules;\n    const totalVotes = this.getTotalVotes(decision);\n    const participationRate = (totalVotes / decision.participants.length) * 100;\n    \n    let shouldComplete = false;\n    let reason = '';\n\n    // Check quorum\n    if (rules.onQuorum && decision.settings.quorum && totalVotes >= decision.settings.quorum) {\n      shouldComplete = true;\n      reason = 'Quorum reached';\n    }\n\n    // Check deadline\n    if (rules.onDeadline && decision.deadline && new Date() >= decision.deadline) {\n      shouldComplete = true;\n      reason = 'Deadline reached';\n    }\n\n    // Check unanimous\n    if (rules.onUnanimous && this.isUnanimous(decision)) {\n      shouldComplete = true;\n      reason = 'Unanimous decision';\n    }\n\n    // Check majority (if all participants have voted)\n    if (rules.onMajority && participationRate >= 100) {\n      shouldComplete = true;\n      reason = 'All participants have voted';\n    }\n\n    if (shouldComplete) {\n      await this.completeDecision(decision.id, 'system');\n      this.logger.log(`Decision ${decision.id} auto-completed: ${reason}`);\n    }\n  }\n\n  private validateVoteValue(decisionType: Decision['type'], value: any): any {\n    switch (decisionType) {\n      case 'vote':\n      case 'binary':\n        return typeof value === 'boolean' ? value : null;\n        \n      case 'ranking':\n        return typeof value === 'number' && value > 0 ? value : null;\n        \n      case 'approval':\n        return typeof value === 'boolean' ? value : null;\n        \n      case 'prioritization':\n        return typeof value === 'number' && value >= 0 ? value : null;\n        \n      default:\n        return value;\n    }\n  }\n\n  private calculateOptionScores(decision: Decision): void {\n    for (const option of decision.options) {\n      let score = 0;\n      \n      switch (decision.type) {\n        case 'vote':\n        case 'binary':\n        case 'approval':\n          score = option.votes.reduce((sum, vote) => {\n            const voteValue = vote.value === true ? 1 : 0;\n            return sum + (voteValue * vote.weight);\n          }, 0);\n          break;\n          \n        case 'ranking':\n          score = option.votes.reduce((sum, vote) => {\n            const rankValue = typeof vote.value === 'number' ? vote.value : 0;\n            return sum + ((6 - rankValue) * vote.weight); // Invert ranking (1st = 5 points)\n          }, 0);\n          break;\n          \n        case 'prioritization':\n          score = option.votes.reduce((sum, vote) => {\n            const priorityValue = typeof vote.value === 'number' ? vote.value : 0;\n            return sum + (priorityValue * vote.weight);\n          }, 0);\n          break;\n      }\n      \n      option.score = score;\n    }\n    \n    // Sort options by score (descending)\n    decision.options.sort((a, b) => b.score - a.score);\n    \n    // Update rankings\n    decision.options.forEach((option, index) => {\n      option.ranking = index + 1;\n    });\n  }\n\n  private calculateDecisionResult(decision: Decision): DecisionResult {\n    const totalVotes = this.getTotalVotes(decision);\n    const participationRate = (totalVotes / decision.participants.length) * 100;\n    \n    const breakdown: DecisionResult['breakdown'] = {};\n    let totalConfidence = 0;\n    let confidenceCount = 0;\n    \n    decision.options.forEach(option => {\n      const votes = option.votes.length;\n      const weightedScore = option.score;\n      const optionConfidence = option.votes.reduce((sum, vote) => sum + vote.confidence, 0) / votes || 0;\n      \n      breakdown[option.id] = {\n        votes,\n        percentage: totalVotes > 0 ? (votes / totalVotes) * 100 : 0,\n        weightedScore,\n        averageConfidence: optionConfidence,\n      };\n      \n      totalConfidence += optionConfidence * votes;\n      confidenceCount += votes;\n    });\n    \n    const averageConfidence = confidenceCount > 0 ? totalConfidence / confidenceCount : 0;\n    const consensusReached = this.checkConsensus(decision);\n    const winningOption = decision.options[0]?.id; // Highest scored option\n    \n    // Analyze support levels\n    const strongSupport = decision.options.filter(o => breakdown[o.id].percentage > 70).map(o => o.id);\n    const weakSupport = decision.options.filter(o => {\n      const pct = breakdown[o.id].percentage;\n      return pct >= 30 && pct <= 70;\n    }).map(o => o.id);\n    const opposition = decision.options.filter(o => breakdown[o.id].percentage < 30).map(o => o.id);\n    \n    // Calculate polarization (standard deviation of vote percentages)\n    const percentages = Object.values(breakdown).map(b => b.percentage);\n    const mean = percentages.reduce((sum, pct) => sum + pct, 0) / percentages.length;\n    const variance = percentages.reduce((sum, pct) => sum + Math.pow(pct - mean, 2), 0) / percentages.length;\n    const polarization = Math.sqrt(variance) / 100; // Normalize to 0-1\n    \n    return {\n      winningOption,\n      totalVotes,\n      participationRate,\n      consensusReached,\n      confidenceScore: averageConfidence,\n      breakdown,\n      analysis: {\n        strongSupport,\n        weakSupport,\n        opposition,\n        polarization,\n        unanimity: this.isUnanimous(decision),\n      },\n    };\n  }\n\n  private getTotalVotes(decision: Decision): number {\n    return decision.options.reduce((sum, option) => sum + option.votes.length, 0);\n  }\n\n  private isUnanimous(decision: Decision): boolean {\n    if (decision.options.length === 0) return false;\n    \n    const firstOptionVotes = decision.options[0].votes.length;\n    return firstOptionVotes > 0 && decision.options.slice(1).every(option => option.votes.length === 0);\n  }\n\n  private checkConsensus(decision: Decision): boolean {\n    if (decision.options.length === 0) return false;\n    \n    const totalVotes = this.getTotalVotes(decision);\n    const topOptionVotes = decision.options[0].votes.length;\n    \n    const consensusThreshold = decision.settings.consensusThreshold || this.CONSENSUS_THRESHOLD;\n    return totalVotes > 0 && (topOptionVotes / totalVotes) >= consensusThreshold;\n  }\n\n  private calculateDecisionMetrics(decision: Decision): DecisionAnalytics['metrics'] {\n    const timeToDecision = decision.completedAt && decision.startsAt \n      ? (decision.completedAt.getTime() - decision.startsAt.getTime()) / (1000 * 60 * 60) // hours\n      : 0;\n    \n    const totalParticipants = decision.participants.length;\n    const votedParticipants = decision.participants.filter(p => p.hasVoted).length;\n    const participationRate = totalParticipants > 0 ? (votedParticipants / totalParticipants) * 100 : 0;\n    \n    const consensusScore = decision.result?.consensusReached ? 100 : \n      decision.result ? (decision.result.breakdown[decision.result.winningOption!]?.percentage || 0) : 0;\n    \n    // Calculate change mind rate (simplified)\n    const changeMindRate = decision.timeline.filter(e => e.type === 'vote_changed').length / votedParticipants * 100;\n    \n    const commentCount = decision.timeline.filter(e => e.type === 'comment_added').length;\n    const commentEngagement = totalParticipants > 0 ? commentCount / totalParticipants : 0;\n    \n    const delegationCount = decision.participants.filter(p => p.delegatedTo).length;\n    const delegationRate = totalParticipants > 0 ? (delegationCount / totalParticipants) * 100 : 0;\n    \n    return {\n      timeToDecision,\n      participationRate,\n      consensusScore,\n      changeMindRate,\n      commentEngagement,\n      delegationRate,\n    };\n  }\n\n  private analyzeParticipants(decision: Decision): DecisionAnalytics['participantAnalysis'] {\n    return decision.participants.map(participant => {\n      const userEvents = decision.timeline.filter(e => e.userId === participant.userId);\n      const engagement = userEvents.length / decision.timeline.length; // Simplified engagement score\n      \n      return {\n        userId: participant.userId,\n        engagement,\n        influence: 0, // Would need historical data to calculate\n        consistency: 0, // Would need historical data to calculate\n        responseTime: 0, // Would need to track response times\n      };\n    });\n  }\n\n  private getWinningOptionText(decision: Decision): string {\n    if (!decision.result?.winningOption) return 'No winner';\n    \n    const winningOption = decision.options.find(o => o.id === decision.result!.winningOption);\n    return winningOption?.text || 'Unknown option';\n  }\n\n  private hasAdminPermission(decision: Decision, userId: string): boolean {\n    // Check if user has admin permissions (would be based on user roles)\n    return false; // Simplified for now\n  }\n\n  private async notifyParticipants(decision: Decision, eventType: string): Promise<void> {\n    for (const participant of decision.participants) {\n      await this.notificationService.sendNotification({\n        userId: participant.userId,\n        type: 'decision',\n        title: `Decision: ${decision.title}`,\n        content: this.getNotificationContent(eventType, decision),\n        context: {\n          roomId: decision.roomId,\n          decisionId: decision.id,\n        },\n      });\n    }\n  }\n\n  private async notifyVoteCast(decision: Decision, vote: Vote, option: DecisionOption): Promise<void> {\n    // Notify other participants about the vote (if not anonymous)\n    if (!vote.isAnonymous) {\n      const otherParticipants = decision.participants.filter(p => p.userId !== vote.userId);\n      \n      for (const participant of otherParticipants) {\n        await this.notificationService.sendNotification({\n          userId: participant.userId,\n          type: 'vote',\n          title: `New vote in: ${decision.title}`,\n          content: `${vote.username} voted for \"${option.text}\"`,\n          context: {\n            roomId: decision.roomId,\n            decisionId: decision.id,\n          },\n        });\n      }\n    }\n  }\n\n  private async notifyMentionedUsers(decision: Decision, comment: DecisionComment): Promise<void> {\n    for (const mentionedUserId of comment.mentions) {\n      await this.notificationService.sendNotification({\n        userId: mentionedUserId,\n        type: 'mention',\n        title: `You were mentioned in: ${decision.title}`,\n        content: comment.content,\n        context: {\n          roomId: decision.roomId,\n          decisionId: decision.id,\n        },\n      });\n    }\n  }\n\n  private getNotificationContent(eventType: string, decision: Decision): string {\n    switch (eventType) {\n      case 'decision_started':\n        return `The decision \"${decision.title}\" is now open for voting.`;\n      case 'decision_completed':\n        return `The decision \"${decision.title}\" has been completed.`;\n      default:\n        return `Update on decision: ${decision.title}`;\n    }\n  }\n\n  private async saveDecision(decision: Decision): Promise<void> {\n    await this.cacheService.set(`decision:${decision.id}`, decision, this.DECISION_TTL);\n  }\n\n  private async addDecisionToRoom(roomId: string, decisionId: string): Promise<void> {\n    const roomDecisionsKey = `room:${roomId}:decisions`;\n    const existingDecisions = await this.cacheService.get<string[]>(roomDecisionsKey) || [];\n    \n    if (!existingDecisions.includes(decisionId)) {\n      existingDecisions.push(decisionId);\n      await this.cacheService.set(roomDecisionsKey, existingDecisions, this.DECISION_TTL);\n    }\n  }\n\n  private async getTemplate(templateId: string): Promise<DecisionTemplate | null> {\n    return await this.cacheService.get<DecisionTemplate>(`decision_template:${templateId}`);\n  }\n\n  private async saveTemplate(template: DecisionTemplate): Promise<void> {\n    await this.cacheService.set(`decision_template:${template.id}`, template, this.DECISION_TTL);\n  }\n\n  private convertToCSV(decision: Decision): string {\n    // Implementation for CSV export\n    let csv = 'Option,Votes,Score,Percentage\\n';\n    \n    const totalVotes = this.getTotalVotes(decision);\n    \n    decision.options.forEach(option => {\n      const votes = option.votes.length;\n      const percentage = totalVotes > 0 ? (votes / totalVotes * 100).toFixed(2) : '0';\n      csv += `\"${option.text}\",${votes},${option.score},${percentage}%\\n`;\n    });\n    \n    return csv;\n  }\n\n  private async convertToPDF(decision: Decision, includeComments: boolean): Promise<string> {\n    // Implementation for PDF export (would use a PDF library)\n    return 'PDF content placeholder';\n  }\n\n  private generateId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n}