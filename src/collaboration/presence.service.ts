import { Injectable, Logger } from '@nestjs/common';\nimport { CacheService } from '../cache/cache.service';\n\nexport interface UserPresence {\n  userId: string;\n  username: string;\n  email?: string;\n  avatar?: string;\n  role: 'hr_manager' | 'recruiter' | 'interviewer' | 'client' | 'admin';\n  status: 'online' | 'away' | 'busy' | 'offline';\n  currentPage?: string;\n  currentContext?: {\n    type: 'candidate' | 'job' | 'document' | 'meeting';\n    id: string;\n    title?: string;\n  };\n  cursor?: {\n    x: number;\n    y: number;\n    page?: string;\n  };\n  selection?: {\n    elementId: string;\n    startOffset: number;\n    endOffset: number;\n    text?: string;\n  };\n  capabilities: UserCapabilities;\n  deviceInfo: {\n    type: 'desktop' | 'tablet' | 'mobile';\n    browser?: string;\n    os?: string;\n  };\n  lastActivity: Date;\n  sessionStart: Date;\n  isTyping?: {\n    contextId: string;\n    contextType: string;\n    startTime: Date;\n  };\n}\n\nexport interface UserCapabilities {\n  canEdit: boolean;\n  canComment: boolean;\n  canVote: boolean;\n  canModerate: boolean;\n  canInvite: boolean;\n  canRecord: boolean;\n  canScreenShare: boolean;\n  maxFileUploadSize: number;\n}\n\nexport interface PresenceUpdate {\n  userId: string;\n  status?: UserPresence['status'];\n  currentPage?: string;\n  currentContext?: UserPresence['currentContext'];\n  cursor?: UserPresence['cursor'];\n  selection?: UserPresence['selection'];\n  isTyping?: UserPresence['isTyping'];\n}\n\nexport interface TeamPresenceSnapshot {\n  roomId: string;\n  timestamp: Date;\n  activeUsers: UserPresence[];\n  totalUsers: number;\n  byStatus: {\n    online: number;\n    away: number;\n    busy: number;\n    offline: number;\n  };\n  byRole: {\n    [role: string]: number;\n  };\n  activeContexts: {\n    [contextId: string]: {\n      type: string;\n      userCount: number;\n      users: string[];\n    };\n  };\n}\n\n@Injectable()\nexport class PresenceService {\n  private readonly logger = new Logger(PresenceService.name);\n  private readonly PRESENCE_TTL = 5 * 60 * 1000; // 5 minutes\n  private readonly TYPING_TIMEOUT = 3000; // 3 seconds\n  private readonly HEARTBEAT_INTERVAL = 30000; // 30 seconds\n\n  constructor(private readonly cacheService: CacheService) {\n    this.startCleanupTimer();\n  }\n\n  /**\n   * Update user presence\n   */\n  async updatePresence(roomId: string, update: PresenceUpdate): Promise<UserPresence | null> {\n    const presenceKey = this.getPresenceKey(roomId, update.userId);\n    const existing = await this.cacheService.get<UserPresence>(presenceKey);\n    \n    if (!existing) {\n      this.logger.warn(`No existing presence found for user ${update.userId} in room ${roomId}`);\n      return null;\n    }\n\n    const updated: UserPresence = {\n      ...existing,\n      ...update,\n      lastActivity: new Date(),\n    };\n\n    // Handle typing indicators\n    if (update.isTyping) {\n      updated.isTyping = {\n        ...update.isTyping,\n        startTime: new Date(),\n      };\n      \n      // Auto-clear typing after timeout\n      setTimeout(() => {\n        this.clearTyping(roomId, update.userId);\n      }, this.TYPING_TIMEOUT);\n    }\n\n    await this.cacheService.set(presenceKey, updated, this.PRESENCE_TTL);\n    \n    // Update room's active users list\n    await this.updateRoomUsersList(roomId, update.userId, updated.status !== 'offline');\n    \n    this.logger.debug(`Updated presence for user ${update.userId} in room ${roomId}`);\n    return updated;\n  }\n\n  /**\n   * Set user online in a room\n   */\n  async setUserOnline(roomId: string, userInfo: Partial<UserPresence>): Promise<UserPresence> {\n    const presence: UserPresence = {\n      userId: userInfo.userId!,\n      username: userInfo.username || 'Unknown User',\n      email: userInfo.email,\n      avatar: userInfo.avatar,\n      role: userInfo.role || 'recruiter',\n      status: 'online',\n      currentPage: userInfo.currentPage,\n      currentContext: userInfo.currentContext,\n      cursor: userInfo.cursor,\n      selection: userInfo.selection,\n      capabilities: userInfo.capabilities || this.getDefaultCapabilities(userInfo.role || 'recruiter'),\n      deviceInfo: userInfo.deviceInfo || { type: 'desktop' },\n      lastActivity: new Date(),\n      sessionStart: new Date(),\n    };\n\n    const presenceKey = this.getPresenceKey(roomId, presence.userId);\n    await this.cacheService.set(presenceKey, presence, this.PRESENCE_TTL);\n    \n    // Add to room's active users\n    await this.updateRoomUsersList(roomId, presence.userId, true);\n    \n    this.logger.log(`User ${presence.userId} joined room ${roomId}`);\n    return presence;\n  }\n\n  /**\n   * Set user offline\n   */\n  async setUserOffline(roomId: string, userId: string): Promise<void> {\n    const presenceKey = this.getPresenceKey(roomId, userId);\n    const existing = await this.cacheService.get<UserPresence>(presenceKey);\n    \n    if (existing) {\n      existing.status = 'offline';\n      existing.lastActivity = new Date();\n      existing.isTyping = undefined;\n      existing.cursor = undefined;\n      existing.selection = undefined;\n      \n      await this.cacheService.set(presenceKey, existing, this.PRESENCE_TTL);\n    }\n    \n    // Remove from room's active users\n    await this.updateRoomUsersList(roomId, userId, false);\n    \n    this.logger.log(`User ${userId} left room ${roomId}`);\n  }\n\n  /**\n   * Get all users present in a room\n   */\n  async getRoomPresence(roomId: string): Promise<UserPresence[]> {\n    const activeUsersKey = this.getRoomUsersKey(roomId);\n    const activeUserIds = await this.cacheService.get<string[]>(activeUsersKey) || [];\n    \n    const presenceList: UserPresence[] = [];\n    \n    for (const userId of activeUserIds) {\n      const presence = await this.cacheService.get<UserPresence>(this.getPresenceKey(roomId, userId));\n      if (presence && presence.status !== 'offline') {\n        presenceList.push(presence);\n      }\n    }\n    \n    return presenceList.sort((a, b) => {\n      // Sort by status (online first), then by role, then by username\n      const statusOrder = { online: 0, busy: 1, away: 2, offline: 3 };\n      const statusDiff = statusOrder[a.status] - statusOrder[b.status];\n      if (statusDiff !== 0) return statusDiff;\n      \n      const roleOrder = { admin: 0, hr_manager: 1, recruiter: 2, interviewer: 3, client: 4 };\n      const roleDiff = roleOrder[a.role] - roleOrder[b.role];\n      if (roleDiff !== 0) return roleDiff;\n      \n      return a.username.localeCompare(b.username);\n    });\n  }\n\n  /**\n   * Get presence snapshot for analytics\n   */\n  async getPresenceSnapshot(roomId: string): Promise<TeamPresenceSnapshot> {\n    const activeUsers = await this.getRoomPresence(roomId);\n    \n    const byStatus = {\n      online: 0,\n      away: 0,\n      busy: 0,\n      offline: 0,\n    };\n    \n    const byRole: { [role: string]: number } = {};\n    const activeContexts: { [contextId: string]: any } = {};\n    \n    activeUsers.forEach(user => {\n      byStatus[user.status]++;\n      byRole[user.role] = (byRole[user.role] || 0) + 1;\n      \n      if (user.currentContext) {\n        const contextId = user.currentContext.id;\n        if (!activeContexts[contextId]) {\n          activeContexts[contextId] = {\n            type: user.currentContext.type,\n            userCount: 0,\n            users: [],\n          };\n        }\n        activeContexts[contextId].userCount++;\n        activeContexts[contextId].users.push(user.userId);\n      }\n    });\n    \n    return {\n      roomId,\n      timestamp: new Date(),\n      activeUsers,\n      totalUsers: activeUsers.length,\n      byStatus,\n      byRole,\n      activeContexts,\n    };\n  }\n\n  /**\n   * Update cursor position for real-time cursor tracking\n   */\n  async updateCursor(roomId: string, userId: string, cursor: UserPresence['cursor']): Promise<void> {\n    const presenceKey = this.getPresenceKey(roomId, userId);\n    const existing = await this.cacheService.get<UserPresence>(presenceKey);\n    \n    if (existing) {\n      existing.cursor = cursor;\n      existing.lastActivity = new Date();\n      await this.cacheService.set(presenceKey, existing, this.PRESENCE_TTL);\n    }\n  }\n\n  /**\n   * Update text selection for collaborative editing\n   */\n  async updateSelection(roomId: string, userId: string, selection: UserPresence['selection']): Promise<void> {\n    const presenceKey = this.getPresenceKey(roomId, userId);\n    const existing = await this.cacheService.get<UserPresence>(presenceKey);\n    \n    if (existing) {\n      existing.selection = selection;\n      existing.lastActivity = new Date();\n      await this.cacheService.set(presenceKey, existing, this.PRESENCE_TTL);\n    }\n  }\n\n  /**\n   * Set/clear typing indicator\n   */\n  async setTyping(roomId: string, userId: string, contextId: string, contextType: string): Promise<void> {\n    const presenceKey = this.getPresenceKey(roomId, userId);\n    const existing = await this.cacheService.get<UserPresence>(presenceKey);\n    \n    if (existing) {\n      existing.isTyping = {\n        contextId,\n        contextType,\n        startTime: new Date(),\n      };\n      existing.lastActivity = new Date();\n      await this.cacheService.set(presenceKey, existing, this.PRESENCE_TTL);\n      \n      // Auto-clear after timeout\n      setTimeout(() => {\n        this.clearTyping(roomId, userId);\n      }, this.TYPING_TIMEOUT);\n    }\n  }\n\n  /**\n   * Clear typing indicator\n   */\n  async clearTyping(roomId: string, userId: string): Promise<void> {\n    const presenceKey = this.getPresenceKey(roomId, userId);\n    const existing = await this.cacheService.get<UserPresence>(presenceKey);\n    \n    if (existing && existing.isTyping) {\n      delete existing.isTyping;\n      existing.lastActivity = new Date();\n      await this.cacheService.set(presenceKey, existing, this.PRESENCE_TTL);\n    }\n  }\n\n  /**\n   * Heartbeat to keep presence alive\n   */\n  async heartbeat(roomId: string, userId: string): Promise<boolean> {\n    const presenceKey = this.getPresenceKey(roomId, userId);\n    const existing = await this.cacheService.get<UserPresence>(presenceKey);\n    \n    if (existing) {\n      existing.lastActivity = new Date();\n      await this.cacheService.set(presenceKey, existing, this.PRESENCE_TTL);\n      return true;\n    }\n    \n    return false;\n  }\n\n  /**\n   * Get users who are currently viewing a specific context (e.g., candidate profile)\n   */\n  async getUsersInContext(roomId: string, contextId: string): Promise<UserPresence[]> {\n    const allUsers = await this.getRoomPresence(roomId);\n    return allUsers.filter(user => \n      user.currentContext?.id === contextId && \n      user.status === 'online'\n    );\n  }\n\n  /**\n   * Get typing users for a specific context\n   */\n  async getTypingUsers(roomId: string, contextId: string): Promise<UserPresence[]> {\n    const allUsers = await this.getRoomPresence(roomId);\n    return allUsers.filter(user => \n      user.isTyping?.contextId === contextId &&\n      user.status === 'online'\n    );\n  }\n\n  /**\n   * Private helper methods\n   */\n  private getPresenceKey(roomId: string, userId: string): string {\n    return `presence:${roomId}:${userId}`;\n  }\n\n  private getRoomUsersKey(roomId: string): string {\n    return `room:${roomId}:users`;\n  }\n\n  private async updateRoomUsersList(roomId: string, userId: string, isActive: boolean): Promise<void> {\n    const usersKey = this.getRoomUsersKey(roomId);\n    const activeUsers = await this.cacheService.get<string[]>(usersKey) || [];\n    \n    if (isActive) {\n      if (!activeUsers.includes(userId)) {\n        activeUsers.push(userId);\n      }\n    } else {\n      const index = activeUsers.indexOf(userId);\n      if (index > -1) {\n        activeUsers.splice(index, 1);\n      }\n    }\n    \n    await this.cacheService.set(usersKey, activeUsers, this.PRESENCE_TTL);\n  }\n\n  private getDefaultCapabilities(role: UserPresence['role']): UserCapabilities {\n    const baseCapabilities: UserCapabilities = {\n      canEdit: false,\n      canComment: true,\n      canVote: true,\n      canModerate: false,\n      canInvite: false,\n      canRecord: false,\n      canScreenShare: false,\n      maxFileUploadSize: 10 * 1024 * 1024, // 10MB\n    };\n\n    switch (role) {\n      case 'admin':\n        return {\n          ...baseCapabilities,\n          canEdit: true,\n          canModerate: true,\n          canInvite: true,\n          canRecord: true,\n          canScreenShare: true,\n          maxFileUploadSize: 100 * 1024 * 1024, // 100MB\n        };\n        \n      case 'hr_manager':\n        return {\n          ...baseCapabilities,\n          canEdit: true,\n          canModerate: true,\n          canInvite: true,\n          canRecord: true,\n          canScreenShare: true,\n          maxFileUploadSize: 50 * 1024 * 1024, // 50MB\n        };\n        \n      case 'recruiter':\n        return {\n          ...baseCapabilities,\n          canEdit: true,\n          canInvite: true,\n          canScreenShare: true,\n          maxFileUploadSize: 25 * 1024 * 1024, // 25MB\n        };\n        \n      case 'interviewer':\n        return {\n          ...baseCapabilities,\n          canEdit: false,\n          canScreenShare: true,\n          maxFileUploadSize: 10 * 1024 * 1024, // 10MB\n        };\n        \n      case 'client':\n        return {\n          ...baseCapabilities,\n          canEdit: false,\n          canVote: false,\n          maxFileUploadSize: 5 * 1024 * 1024, // 5MB\n        };\n        \n      default:\n        return baseCapabilities;\n    }\n  }\n\n  /**\n   * Cleanup expired presence data\n   */\n  private startCleanupTimer(): void {\n    setInterval(async () => {\n      await this.cleanupExpiredPresence();\n    }, this.HEARTBEAT_INTERVAL);\n  }\n\n  private async cleanupExpiredPresence(): Promise<void> {\n    // This would typically scan for expired presence records\n    // Implementation depends on cache service capabilities\n    this.logger.debug('Running presence cleanup...');\n  }\n}