import { Injectable, Logger } from '@nestjs/common';\nimport { CacheService } from '../cache/cache.service';\nimport { WebSocketService } from './websocket.service';\nimport { PresenceService } from './presence.service';\n\n// Operational Transform types for real-time collaboration\nexport interface Operation {\n  id: string;\n  type: 'insert' | 'delete' | 'retain' | 'format' | 'annotate';\n  position: number;\n  content?: string;\n  length?: number;\n  attributes?: Record<string, any>;\n  userId: string;\n  timestamp: Date;\n  version: number;\n}\n\nexport interface DocumentState {\n  id: string;\n  content: string;\n  version: number;\n  operations: Operation[];\n  participants: DocumentParticipant[];\n  lastModified: Date;\n  metadata: {\n    title: string;\n    type: 'resume' | 'job_description' | 'interview_notes' | 'evaluation' | 'contract';\n    candidateId?: string;\n    jobId?: string;\n    tags: string[];\n    permissions: DocumentPermissions;\n  };\n}\n\nexport interface DocumentParticipant {\n  userId: string;\n  username: string;\n  role: 'owner' | 'editor' | 'viewer' | 'commenter';\n  joinedAt: Date;\n  lastSeen: Date;\n  cursor?: {\n    position: number;\n    selection?: { start: number; end: number };\n  };\n  isActive: boolean;\n}\n\nexport interface DocumentPermissions {\n  read: string[]; // User IDs\n  write: string[];\n  comment: string[];\n  admin: string[];\n  public: boolean;\n}\n\nexport interface Comment {\n  id: string;\n  documentId: string;\n  content: string;\n  authorId: string;\n  authorName: string;\n  position: number;\n  range?: { start: number; end: number };\n  parentId?: string; // For replies\n  resolved: boolean;\n  createdAt: Date;\n  updatedAt?: Date;\n  mentions: string[];\n  reactions: CommentReaction[];\n}\n\nexport interface CommentReaction {\n  emoji: string;\n  userId: string;\n  timestamp: Date;\n}\n\nexport interface Annotation {\n  id: string;\n  documentId: string;\n  type: 'highlight' | 'note' | 'suggestion' | 'correction';\n  position: number;\n  length: number;\n  content: string;\n  authorId: string;\n  authorName: string;\n  category?: 'skill' | 'experience' | 'education' | 'concern' | 'strength';\n  confidence?: number; // 0-1 for AI suggestions\n  createdAt: Date;\n  resolved: boolean;\n}\n\nexport interface DocumentVersion {\n  id: string;\n  documentId: string;\n  content: string;\n  version: number;\n  authorId: string;\n  authorName: string;\n  description: string;\n  createdAt: Date;\n  operations: Operation[];\n}\n\nexport interface ConflictResolution {\n  operationId: string;\n  resolution: 'accept' | 'reject' | 'merge';\n  mergedContent?: string;\n  resolvedBy: string;\n  timestamp: Date;\n}\n\n@Injectable()\nexport class CollaborativeEditorService {\n  private readonly logger = new Logger(CollaborativeEditorService.name);\n  private readonly DOCUMENT_TTL = 24 * 60 * 60 * 1000; // 24 hours\n  private readonly MAX_OPERATIONS_HISTORY = 1000;\n  private readonly CONFLICT_RESOLUTION_TIMEOUT = 30000; // 30 seconds\n\n  constructor(\n    private readonly cacheService: CacheService,\n    private readonly presenceService: PresenceService\n  ) {}\n\n  /**\n   * Create a new collaborative document\n   */\n  async createDocument(documentData: Partial<DocumentState>): Promise<DocumentState> {\n    const document: DocumentState = {\n      id: this.generateId(),\n      content: documentData.content || '',\n      version: 1,\n      operations: [],\n      participants: [],\n      lastModified: new Date(),\n      metadata: {\n        title: documentData.metadata?.title || 'Untitled Document',\n        type: documentData.metadata?.type || 'resume',\n        candidateId: documentData.metadata?.candidateId,\n        jobId: documentData.metadata?.jobId,\n        tags: documentData.metadata?.tags || [],\n        permissions: {\n          read: [],\n          write: [],\n          comment: [],\n          admin: [],\n          public: false,\n          ...documentData.metadata?.permissions,\n        },\n      },\n    };\n\n    await this.cacheService.set(`document:${document.id}`, document, this.DOCUMENT_TTL);\n    \n    this.logger.log(`Created document ${document.id}: ${document.metadata.title}`);\n    return document;\n  }\n\n  /**\n   * Get document by ID\n   */\n  async getDocument(documentId: string): Promise<DocumentState | null> {\n    return await this.cacheService.get<DocumentState>(`document:${documentId}`);\n  }\n\n  /**\n   * Join document editing session\n   */\n  async joinDocument(\n    documentId: string, \n    userId: string, \n    username: string, \n    role: DocumentParticipant['role'] = 'viewer'\n  ): Promise<DocumentState | null> {\n    const document = await this.getDocument(documentId);\n    if (!document) return null;\n\n    // Check permissions\n    if (!this.hasReadPermission(document, userId)) {\n      throw new Error('Insufficient permissions to access document');\n    }\n\n    // Update or add participant\n    const existingParticipant = document.participants.find(p => p.userId === userId);\n    if (existingParticipant) {\n      existingParticipant.lastSeen = new Date();\n      existingParticipant.isActive = true;\n    } else {\n      document.participants.push({\n        userId,\n        username,\n        role: this.determineUserRole(document, userId, role),\n        joinedAt: new Date(),\n        lastSeen: new Date(),\n        isActive: true,\n      });\n    }\n\n    await this.saveDocument(document);\n    \n    // Update presence\n    await this.presenceService.updatePresence(documentId, {\n      userId,\n      currentContext: {\n        type: 'document',\n        id: documentId,\n        title: document.metadata.title,\n      },\n    });\n\n    this.logger.log(`User ${userId} joined document ${documentId}`);\n    return document;\n  }\n\n  /**\n   * Leave document editing session\n   */\n  async leaveDocument(documentId: string, userId: string): Promise<void> {\n    const document = await this.getDocument(documentId);\n    if (!document) return;\n\n    const participant = document.participants.find(p => p.userId === userId);\n    if (participant) {\n      participant.isActive = false;\n      participant.lastSeen = new Date();\n    }\n\n    await this.saveDocument(document);\n    \n    this.logger.log(`User ${userId} left document ${documentId}`);\n  }\n\n  /**\n   * Apply operation to document with operational transform\n   */\n  async applyOperation(\n    documentId: string, \n    operation: Omit<Operation, 'id' | 'timestamp' | 'version'>\n  ): Promise<{ success: boolean; transformedOperation?: Operation; conflicts?: Operation[] }> {\n    const document = await this.getDocument(documentId);\n    if (!document) {\n      return { success: false };\n    }\n\n    // Check write permissions\n    if (!this.hasWritePermission(document, operation.userId)) {\n      throw new Error('Insufficient permissions to edit document');\n    }\n\n    const fullOperation: Operation = {\n      ...operation,\n      id: this.generateId(),\n      timestamp: new Date(),\n      version: document.version + 1,\n    };\n\n    // Get concurrent operations (operations with same or higher version)\n    const concurrentOps = document.operations.filter(op => op.version >= operation.version);\n\n    if (concurrentOps.length === 0) {\n      // No conflicts, apply directly\n      return await this.applyOperationDirect(document, fullOperation);\n    } else {\n      // Transform operation against concurrent operations\n      return await this.transformAndApplyOperation(document, fullOperation, concurrentOps);\n    }\n  }\n\n  /**\n   * Update cursor position for user\n   */\n  async updateCursor(\n    documentId: string, \n    userId: string, \n    position: number, \n    selection?: { start: number; end: number }\n  ): Promise<void> {\n    const document = await this.getDocument(documentId);\n    if (!document) return;\n\n    const participant = document.participants.find(p => p.userId === userId);\n    if (participant) {\n      participant.cursor = { position, selection };\n      participant.lastSeen = new Date();\n      await this.saveDocument(document);\n\n      // Update presence\n      await this.presenceService.updateCursor(documentId, userId, {\n        x: position % 80, // Mock cursor position\n        y: Math.floor(position / 80),\n        page: documentId,\n      });\n    }\n  }\n\n  /**\n   * Add comment to document\n   */\n  async addComment(\n    documentId: string, \n    commentData: Omit<Comment, 'id' | 'createdAt' | 'reactions'>\n  ): Promise<Comment> {\n    const comment: Comment = {\n      ...commentData,\n      id: this.generateId(),\n      createdAt: new Date(),\n      reactions: [],\n    };\n\n    const commentsKey = `document:${documentId}:comments`;\n    const existingComments = await this.cacheService.get<Comment[]>(commentsKey) || [];\n    existingComments.push(comment);\n    \n    await this.cacheService.set(commentsKey, existingComments, this.DOCUMENT_TTL);\n    \n    // Notify mentioned users\n    if (comment.mentions.length > 0) {\n      await this.notifyMentionedUsers(documentId, comment);\n    }\n\n    this.logger.log(`Comment added to document ${documentId} by ${comment.authorId}`);\n    return comment;\n  }\n\n  /**\n   * Add annotation to document\n   */\n  async addAnnotation(\n    documentId: string, \n    annotationData: Omit<Annotation, 'id' | 'createdAt'>\n  ): Promise<Annotation> {\n    const annotation: Annotation = {\n      ...annotationData,\n      id: this.generateId(),\n      createdAt: new Date(),\n    };\n\n    const annotationsKey = `document:${documentId}:annotations`;\n    const existingAnnotations = await this.cacheService.get<Annotation[]>(annotationsKey) || [];\n    existingAnnotations.push(annotation);\n    \n    await this.cacheService.set(annotationsKey, existingAnnotations, this.DOCUMENT_TTL);\n    \n    this.logger.log(`Annotation added to document ${documentId} by ${annotation.authorId}`);\n    return annotation;\n  }\n\n  /**\n   * Get document comments\n   */\n  async getComments(documentId: string): Promise<Comment[]> {\n    const commentsKey = `document:${documentId}:comments`;\n    return await this.cacheService.get<Comment[]>(commentsKey) || [];\n  }\n\n  /**\n   * Get document annotations\n   */\n  async getAnnotations(documentId: string): Promise<Annotation[]> {\n    const annotationsKey = `document:${documentId}:annotations`;\n    return await this.cacheService.get<Annotation[]>(annotationsKey) || [];\n  }\n\n  /**\n   * Create document version/snapshot\n   */\n  async createVersion(\n    documentId: string, \n    authorId: string, \n    authorName: string, \n    description: string\n  ): Promise<DocumentVersion> {\n    const document = await this.getDocument(documentId);\n    if (!document) {\n      throw new Error('Document not found');\n    }\n\n    const version: DocumentVersion = {\n      id: this.generateId(),\n      documentId,\n      content: document.content,\n      version: document.version,\n      authorId,\n      authorName,\n      description,\n      createdAt: new Date(),\n      operations: [...document.operations],\n    };\n\n    const versionsKey = `document:${documentId}:versions`;\n    const existingVersions = await this.cacheService.get<DocumentVersion[]>(versionsKey) || [];\n    existingVersions.push(version);\n    \n    // Keep only last 50 versions\n    if (existingVersions.length > 50) {\n      existingVersions.splice(0, existingVersions.length - 50);\n    }\n    \n    await this.cacheService.set(versionsKey, existingVersions, this.DOCUMENT_TTL);\n    \n    this.logger.log(`Version created for document ${documentId}: ${description}`);\n    return version;\n  }\n\n  /**\n   * Restore document to specific version\n   */\n  async restoreVersion(documentId: string, versionId: string, userId: string): Promise<DocumentState | null> {\n    const document = await this.getDocument(documentId);\n    if (!document) return null;\n\n    if (!this.hasWritePermission(document, userId)) {\n      throw new Error('Insufficient permissions to restore version');\n    }\n\n    const versionsKey = `document:${documentId}:versions`;\n    const versions = await this.cacheService.get<DocumentVersion[]>(versionsKey) || [];\n    const targetVersion = versions.find(v => v.id === versionId);\n    \n    if (!targetVersion) {\n      throw new Error('Version not found');\n    }\n\n    // Create backup of current state\n    await this.createVersion(\n      documentId, \n      userId, \n      'System', \n      `Backup before restoring to version ${targetVersion.version}`\n    );\n\n    // Restore content and increment version\n    document.content = targetVersion.content;\n    document.version = document.version + 1;\n    document.lastModified = new Date();\n    \n    // Clear operations history after restoration\n    document.operations = [];\n\n    await this.saveDocument(document);\n    \n    this.logger.log(`Document ${documentId} restored to version ${targetVersion.version}`);\n    return document;\n  }\n\n  /**\n   * Export document in various formats\n   */\n  async exportDocument(\n    documentId: string, \n    format: 'html' | 'markdown' | 'pdf' | 'docx',\n    includeComments: boolean = false\n  ): Promise<{ content: string; mimeType: string }> {\n    const document = await this.getDocument(documentId);\n    if (!document) {\n      throw new Error('Document not found');\n    }\n\n    let exportedContent = document.content;\n    const mimeTypes = {\n      html: 'text/html',\n      markdown: 'text/markdown',\n      pdf: 'application/pdf',\n      docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\n    };\n\n    if (includeComments) {\n      const comments = await this.getComments(documentId);\n      exportedContent = this.embedCommentsInContent(exportedContent, comments, format);\n    }\n\n    switch (format) {\n      case 'html':\n        exportedContent = this.convertToHtml(exportedContent);\n        break;\n      case 'markdown':\n        exportedContent = this.convertToMarkdown(exportedContent);\n        break;\n      case 'pdf':\n        exportedContent = await this.convertToPdf(exportedContent);\n        break;\n      case 'docx':\n        exportedContent = await this.convertToDocx(exportedContent);\n        break;\n    }\n\n    return {\n      content: exportedContent,\n      mimeType: mimeTypes[format]\n    };\n  }\n\n  /**\n   * Search within document content\n   */\n  async searchDocument(\n    documentId: string, \n    query: string, \n    options: {\n      caseSensitive?: boolean;\n      wholeWords?: boolean;\n      includeComments?: boolean;\n      includeAnnotations?: boolean;\n    } = {}\n  ): Promise<{\n    content: Array<{ position: number; length: number; context: string }>;\n    comments: Array<{ commentId: string; position: number; context: string }>;\n    annotations: Array<{ annotationId: string; position: number; context: string }>;\n  }> {\n    const document = await this.getDocument(documentId);\n    if (!document) {\n      throw new Error('Document not found');\n    }\n\n    const results = {\n      content: [] as Array<{ position: number; length: number; context: string }>,\n      comments: [] as Array<{ commentId: string; position: number; context: string }>,\n      annotations: [] as Array<{ annotationId: string; position: number; context: string }>\n    };\n\n    // Search in document content\n    const contentMatches = this.searchInText(document.content, query, options);\n    results.content = contentMatches.map(match => ({\n      position: match.index,\n      length: match.length,\n      context: this.getSearchContext(document.content, match.index, 50)\n    }));\n\n    // Search in comments if requested\n    if (options.includeComments) {\n      const comments = await this.getComments(documentId);\n      for (const comment of comments) {\n        const commentMatches = this.searchInText(comment.content, query, options);\n        results.comments.push(...commentMatches.map(match => ({\n          commentId: comment.id,\n          position: match.index,\n          context: this.getSearchContext(comment.content, match.index, 30)\n        })));\n      }\n    }\n\n    // Search in annotations if requested\n    if (options.includeAnnotations) {\n      const annotations = await this.getAnnotations(documentId);\n      for (const annotation of annotations) {\n        const annotationMatches = this.searchInText(annotation.content, query, options);\n        results.annotations.push(...annotationMatches.map(match => ({\n          annotationId: annotation.id,\n          position: match.index,\n          context: this.getSearchContext(annotation.content, match.index, 30)\n        })));\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Private helper methods\n   */\n  private async applyOperationDirect(\n    document: DocumentState, \n    operation: Operation\n  ): Promise<{ success: boolean; transformedOperation: Operation }> {\n    try {\n      // Apply operation to content\n      document.content = this.applyOperationToText(document.content, operation);\n      document.version = operation.version;\n      document.lastModified = new Date();\n      \n      // Add to operations history\n      document.operations.push(operation);\n      \n      // Limit operations history\n      if (document.operations.length > this.MAX_OPERATIONS_HISTORY) {\n        document.operations.splice(0, document.operations.length - this.MAX_OPERATIONS_HISTORY);\n      }\n      \n      await this.saveDocument(document);\n      \n      return { success: true, transformedOperation: operation };\n    } catch (error) {\n      this.logger.error(`Failed to apply operation: ${error.message}`);\n      return { success: false, transformedOperation: operation };\n    }\n  }\n\n  private async transformAndApplyOperation(\n    document: DocumentState,\n    operation: Operation,\n    concurrentOps: Operation[]\n  ): Promise<{ success: boolean; transformedOperation?: Operation; conflicts?: Operation[] }> {\n    try {\n      let transformedOp = operation;\n      const conflicts: Operation[] = [];\n      \n      // Transform against each concurrent operation\n      for (const concurrentOp of concurrentOps) {\n        const result = this.transformOperations(transformedOp, concurrentOp);\n        transformedOp = result.transformedOp;\n        \n        if (result.hasConflict) {\n          conflicts.push(concurrentOp);\n        }\n      }\n      \n      if (conflicts.length > 0) {\n        // Handle conflicts\n        const resolution = await this.resolveConflicts(document, transformedOp, conflicts);\n        if (!resolution.success) {\n          return { success: false, conflicts };\n        }\n        transformedOp = resolution.resolvedOperation;\n      }\n      \n      // Apply transformed operation\n      const result = await this.applyOperationDirect(document, transformedOp);\n      return { ...result, conflicts: conflicts.length > 0 ? conflicts : undefined };\n    } catch (error) {\n      this.logger.error(`Failed to transform and apply operation: ${error.message}`);\n      return { success: false, conflicts: concurrentOps };\n    }\n  }\n\n  private transformOperations(\n    op1: Operation, \n    op2: Operation\n  ): { transformedOp: Operation; hasConflict: boolean } {\n    // Simplified operational transform - in production, use a library like ShareJS\n    let transformedOp = { ...op1 };\n    let hasConflict = false;\n    \n    if (op1.type === 'insert' && op2.type === 'insert') {\n      if (op2.position <= op1.position) {\n        transformedOp.position += op2.content?.length || 0;\n      }\n    } else if (op1.type === 'insert' && op2.type === 'delete') {\n      if (op2.position < op1.position) {\n        transformedOp.position -= Math.min(op2.length || 0, op1.position - op2.position);\n      } else if (op2.position < op1.position + (op1.content?.length || 0)) {\n        hasConflict = true;\n      }\n    } else if (op1.type === 'delete' && op2.type === 'insert') {\n      if (op2.position <= op1.position) {\n        transformedOp.position += op2.content?.length || 0;\n      }\n    } else if (op1.type === 'delete' && op2.type === 'delete') {\n      if (op2.position < op1.position) {\n        transformedOp.position -= Math.min(op2.length || 0, op1.position - op2.position);\n      } else if (op2.position < op1.position + (op1.length || 0)) {\n        hasConflict = true;\n      }\n    }\n    \n    return { transformedOp, hasConflict };\n  }\n\n  private async resolveConflicts(\n    document: DocumentState,\n    operation: Operation,\n    conflicts: Operation[]\n  ): Promise<{ success: boolean; resolvedOperation: Operation }> {\n    // Simple conflict resolution - in production, implement sophisticated strategies\n    \n    // Strategy 1: Last write wins (for now)\n    // Strategy 2: User priority based on role\n    // Strategy 3: Manual resolution\n    \n    this.logger.warn(`Conflict detected for document ${document.id}, applying last-write-wins strategy`);\n    \n    return {\n      success: true,\n      resolvedOperation: operation\n    };\n  }\n\n  private applyOperationToText(content: string, operation: Operation): string {\n    let result = content;\n    \n    switch (operation.type) {\n      case 'insert':\n        result = content.slice(0, operation.position) + \n                 (operation.content || '') + \n                 content.slice(operation.position);\n        break;\n        \n      case 'delete':\n        result = content.slice(0, operation.position) + \n                 content.slice(operation.position + (operation.length || 0));\n        break;\n        \n      case 'retain':\n        // No change to content for retain operations\n        break;\n        \n      case 'format':\n        // Apply formatting (would need more sophisticated implementation)\n        break;\n    }\n    \n    return result;\n  }\n\n  private async saveDocument(document: DocumentState): Promise<void> {\n    await this.cacheService.set(`document:${document.id}`, document, this.DOCUMENT_TTL);\n  }\n\n  private hasReadPermission(document: DocumentState, userId: string): boolean {\n    const permissions = document.metadata.permissions;\n    return (\n      permissions.public ||\n      permissions.read.includes(userId) ||\n      permissions.write.includes(userId) ||\n      permissions.admin.includes(userId)\n    );\n  }\n\n  private hasWritePermission(document: DocumentState, userId: string): boolean {\n    const permissions = document.metadata.permissions;\n    return (\n      permissions.write.includes(userId) ||\n      permissions.admin.includes(userId)\n    );\n  }\n\n  private determineUserRole(\n    document: DocumentState, \n    userId: string, \n    requestedRole: DocumentParticipant['role']\n  ): DocumentParticipant['role'] {\n    const permissions = document.metadata.permissions;\n    \n    if (permissions.admin.includes(userId)) return 'owner';\n    if (permissions.write.includes(userId)) return 'editor';\n    if (permissions.comment.includes(userId)) return 'commenter';\n    \n    return 'viewer';\n  }\n\n  private async notifyMentionedUsers(documentId: string, comment: Comment): Promise<void> {\n    // Implementation would send notifications to mentioned users\n    this.logger.log(`Notifying ${comment.mentions.length} users about mention in document ${documentId}`);\n  }\n\n  private embedCommentsInContent(content: string, comments: Comment[], format: string): string {\n    // Implementation would embed comments based on format\n    return content; // Simplified\n  }\n\n  private convertToHtml(content: string): string {\n    // Convert to HTML with proper formatting\n    return `<html><body>${content.replace(/\\n/g, '<br>')}</body></html>`;\n  }\n\n  private convertToMarkdown(content: string): string {\n    // Convert to Markdown format\n    return content; // Already in markdown-like format\n  }\n\n  private async convertToPdf(content: string): Promise<string> {\n    // Implementation would use a PDF library\n    return content; // Simplified\n  }\n\n  private async convertToDocx(content: string): Promise<string> {\n    // Implementation would use a DOCX library\n    return content; // Simplified\n  }\n\n  private searchInText(\n    text: string, \n    query: string, \n    options: { caseSensitive?: boolean; wholeWords?: boolean }\n  ): Array<{ index: number; length: number }> {\n    const flags = options.caseSensitive ? 'g' : 'gi';\n    const searchQuery = options.wholeWords ? `\\\\b${query}\\\\b` : query;\n    const regex = new RegExp(searchQuery, flags);\n    \n    const matches: Array<{ index: number; length: number }> = [];\n    let match;\n    \n    while ((match = regex.exec(text)) !== null) {\n      matches.push({\n        index: match.index,\n        length: match[0].length\n      });\n    }\n    \n    return matches;\n  }\n\n  private getSearchContext(text: string, position: number, contextLength: number): string {\n    const start = Math.max(0, position - contextLength);\n    const end = Math.min(text.length, position + contextLength);\n    return text.slice(start, end);\n  }\n\n  private generateId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n}