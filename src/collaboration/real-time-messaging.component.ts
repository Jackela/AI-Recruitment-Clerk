import { Component, OnInit, OnDestroy, ViewChild, ElementRef, signal, computed, inject, input } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\nimport { Subject, takeUntil, debounceTime, distinctUntilChanged } from 'rxjs';\nimport { WebSocketService } from '../services/websocket.service';\nimport { CollaborationService } from '../services/collaboration.service';\nimport { PresenceService } from '../services/presence.service';\nimport { NotificationService } from '../services/notification.service';\n\ninterface Message {\n  id: string;\n  type: 'text' | 'file' | 'image' | 'annotation' | 'system' | 'vote_created' | 'decision_made';\n  content: string;\n  authorId: string;\n  authorName: string;\n  authorAvatar?: string;\n  contextData?: {\n    candidateId?: string;\n    documentId?: string;\n    annotationPosition?: { x: number; y: number };\n    voteId?: string;\n    decisionId?: string;\n  };\n  mentions: string[];\n  attachments: MessageAttachment[];\n  reactions: MessageReaction[];\n  threadId?: string;\n  replyToId?: string;\n  timestamp: Date;\n  editedAt?: Date;\n  isDeleted: boolean;\n  isTyping?: boolean;\n}\n\ninterface MessageAttachment {\n  id: string;\n  filename: string;\n  mimetype: string;\n  size: number;\n  url: string;\n  thumbnailUrl?: string;\n}\n\ninterface MessageReaction {\n  emoji: string;\n  userId: string;\n  username: string;\n  timestamp: Date;\n}\n\ninterface TypingUser {\n  userId: string;\n  username: string;\n  avatar?: string;\n  timestamp: Date;\n}\n\ninterface MessageThread {\n  id: string;\n  parentMessageId: string;\n  messages: Message[];\n  participantCount: number;\n  lastActivity: Date;\n}\n\ninterface UserMention {\n  userId: string;\n  username: string;\n  displayName: string;\n  avatar?: string;\n  role: string;\n}\n\n@Component({\n  selector: 'app-real-time-messaging',\n  standalone: true,\n  imports: [CommonModule, FormsModule],\n  template: `\n    <div class=\"messaging-container\" [class.thread-mode]=\"activeThread()\">\n      <!-- Message Header -->\n      <div class=\"message-header\">\n        <div class=\"header-info\">\n          <h3 class=\"room-title\">{{ roomName() }}</h3>\n          <div class=\"participant-count\">\n            <i class=\"icon-users\"></i>\n            {{ participantCount() }} participants\n          </div>\n        </div>\n        <div class=\"header-actions\">\n          <button class=\"action-btn\" (click)=\"toggleMentions()\" [class.active]=\"showMentions()\">\n            <i class=\"icon-at\"></i>\n            <span class=\"notification-badge\" *ngIf=\"unreadMentions() > 0\">\n              {{ unreadMentions() }}\n            </span>\n          </button>\n          <button class=\"action-btn\" (click)=\"toggleThreads()\" [class.active]=\"showThreads()\">\n            <i class=\"icon-thread\"></i>\n            Threads\n          </button>\n          <button class=\"action-btn\" (click)=\"shareScreen()\">\n            <i class=\"icon-screen\"></i>\n            Share\n          </button>\n          <button class=\"action-btn\" (click)=\"startCall()\">\n            <i class=\"icon-video\"></i>\n            Call\n          </button>\n        </div>\n      </div>\n\n      <!-- Messages Area -->\n      <div class=\"messages-area\">\n        <!-- Main Messages -->\n        <div class=\"messages-list\" #messagesContainer>\n          <div \n            *ngFor=\"let message of displayedMessages(); trackBy: trackByMessageId\"\n            class=\"message-wrapper\"\n            [class.own-message]=\"message.authorId === currentUserId()\"\n            [class.system-message]=\"message.type === 'system'\"\n            [class.highlighted]=\"highlightedMessageId() === message.id\">\n            \n            <!-- Message Content -->\n            <div class=\"message-content\">\n              <!-- Author Info -->\n              <div class=\"message-author\" *ngIf=\"!isConsecutiveMessage(message)\">\n                <img \n                  [src]=\"message.authorAvatar || '/assets/default-avatar.png'\" \n                  [alt]=\"message.authorName\"\n                  class=\"author-avatar\">\n                <span class=\"author-name\">{{ message.authorName }}</span>\n                <span class=\"message-time\">{{ message.timestamp | date:'short' }}</span>\n                <span class=\"edited-indicator\" *ngIf=\"message.editedAt\">(edited)</span>\n              </div>\n\n              <!-- Message Text -->\n              <div class=\"message-text\" [innerHTML]=\"formatMessageContent(message.content)\"></div>\n\n              <!-- Attachments -->\n              <div class=\"message-attachments\" *ngIf=\"message.attachments.length > 0\">\n                <div \n                  *ngFor=\"let attachment of message.attachments\"\n                  class=\"attachment-item\"\n                  [class]=\"getAttachmentClass(attachment.mimetype)\">\n                  <div class=\"attachment-preview\" *ngIf=\"isImageAttachment(attachment)\">\n                    <img [src]=\"attachment.thumbnailUrl || attachment.url\" [alt]=\"attachment.filename\">\n                  </div>\n                  <div class=\"attachment-info\">\n                    <div class=\"attachment-name\">{{ attachment.filename }}</div>\n                    <div class=\"attachment-meta\">\n                      {{ formatFileSize(attachment.size) }} â€¢ {{ attachment.mimetype }}\n                    </div>\n                  </div>\n                  <button class=\"download-btn\" (click)=\"downloadAttachment(attachment)\">\n                    <i class=\"icon-download\"></i>\n                  </button>\n                </div>\n              </div>\n\n              <!-- Context Data -->\n              <div class=\"message-context\" *ngIf=\"message.contextData\">\n                <div class=\"context-preview\" [ngSwitch]=\"getContextType(message.contextData)\">\n                  <div *ngSwitchCase=\"'candidate'\" class=\"candidate-context\">\n                    <i class=\"icon-user\"></i>\n                    <span>Candidate: {{ message.contextData.candidateId }}</span>\n                  </div>\n                  <div *ngSwitchCase=\"'document'\" class=\"document-context\">\n                    <i class=\"icon-file\"></i>\n                    <span>Document: {{ message.contextData.documentId }}</span>\n                  </div>\n                  <div *ngSwitchCase=\"'vote'\" class=\"vote-context\">\n                    <i class=\"icon-vote\"></i>\n                    <span>Vote: {{ message.contextData.voteId }}</span>\n                  </div>\n                </div>\n              </div>\n\n              <!-- Reactions -->\n              <div class=\"message-reactions\" *ngIf=\"message.reactions.length > 0\">\n                <div \n                  *ngFor=\"let reaction of getGroupedReactions(message.reactions)\"\n                  class=\"reaction-item\"\n                  [class.own-reaction]=\"hasUserReacted(reaction, currentUserId())\"\n                  (click)=\"toggleReaction(message.id, reaction.emoji)\"\n                  [title]=\"getReactionTooltip(reaction)\">\n                  <span class=\"reaction-emoji\">{{ reaction.emoji }}</span>\n                  <span class=\"reaction-count\">{{ reaction.users.length }}</span>\n                </div>\n                <button class=\"add-reaction-btn\" (click)=\"showEmojiPicker(message.id)\">\n                  <i class=\"icon-plus\"></i>\n                </button>\n              </div>\n            </div>\n\n            <!-- Message Actions -->\n            <div class=\"message-actions\">\n              <button class=\"action-btn\" (click)=\"addReaction(message.id)\" title=\"Add Reaction\">\n                <i class=\"icon-smile\"></i>\n              </button>\n              <button class=\"action-btn\" (click)=\"replyToMessage(message)\" title=\"Reply\">\n                <i class=\"icon-reply\"></i>\n              </button>\n              <button class=\"action-btn\" (click)=\"startThread(message)\" title=\"Start Thread\">\n                <i class=\"icon-thread\"></i>\n              </button>\n              <button \n                class=\"action-btn\" \n                (click)=\"editMessage(message)\" \n                *ngIf=\"canEditMessage(message)\"\n                title=\"Edit\">\n                <i class=\"icon-edit\"></i>\n              </button>\n              <button \n                class=\"action-btn danger\" \n                (click)=\"deleteMessage(message.id)\" \n                *ngIf=\"canDeleteMessage(message)\"\n                title=\"Delete\">\n                <i class=\"icon-trash\"></i>\n              </button>\n            </div>\n          </div>\n\n          <!-- Typing Indicators -->\n          <div class=\"typing-indicators\" *ngIf=\"typingUsers().length > 0\">\n            <div class=\"typing-item\" *ngFor=\"let user of typingUsers()\">\n              <img [src]=\"user.avatar || '/assets/default-avatar.png'\" [alt]=\"user.username\">\n              <div class=\"typing-animation\">\n                <div class=\"typing-dots\">\n                  <span></span><span></span><span></span>\n                </div>\n                <span class=\"typing-text\">{{ user.username }} is typing...</span>\n              </div>\n            </div>\n          </div>\n        </div>\n\n        <!-- Thread Panel -->\n        <div class=\"thread-panel\" *ngIf=\"activeThread()\" [@slideIn]>\n          <div class=\"thread-header\">\n            <h4 class=\"thread-title\">Thread</h4>\n            <button class=\"close-btn\" (click)=\"closeThread()\">\n              <i class=\"icon-x\"></i>\n            </button>\n          </div>\n          <div class=\"thread-messages\">\n            <div \n              *ngFor=\"let message of activeThread()?.messages; trackBy: trackByMessageId\"\n              class=\"thread-message\"\n              [class.own-message]=\"message.authorId === currentUserId()\">\n              <div class=\"message-content\">\n                <div class=\"message-author\">\n                  <img [src]=\"message.authorAvatar || '/assets/default-avatar.png'\" [alt]=\"message.authorName\">\n                  <span class=\"author-name\">{{ message.authorName }}</span>\n                  <span class=\"message-time\">{{ message.timestamp | date:'short' }}</span>\n                </div>\n                <div class=\"message-text\" [innerHTML]=\"formatMessageContent(message.content)\"></div>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <!-- Message Input -->\n      <div class=\"message-input-area\">\n        <!-- Reply Preview -->\n        <div class=\"reply-preview\" *ngIf=\"replyingTo()\">\n          <div class=\"reply-content\">\n            <i class=\"icon-reply\"></i>\n            <span class=\"reply-text\">Replying to {{ replyingTo()?.authorName }}</span>\n            <div class=\"reply-message\">{{ replyingTo()?.content }}</div>\n          </div>\n          <button class=\"cancel-btn\" (click)=\"cancelReply()\">\n            <i class=\"icon-x\"></i>\n          </button>\n        </div>\n\n        <!-- Mentions Dropdown -->\n        <div class=\"mentions-dropdown\" *ngIf=\"showMentionsDropdown() && filteredMentions().length > 0\">\n          <div \n            *ngFor=\"let mention of filteredMentions(); let i = index\"\n            class=\"mention-item\"\n            [class.selected]=\"selectedMentionIndex() === i\"\n            (click)=\"insertMention(mention)\"\n            (mouseenter)=\"selectedMentionIndex.set(i)\">\n            <img [src]=\"mention.avatar || '/assets/default-avatar.png'\" [alt]=\"mention.username\">\n            <div class=\"mention-info\">\n              <div class=\"mention-name\">{{ mention.displayName }}</div>\n              <div class=\"mention-role\">{{ mention.role }}</div>\n            </div>\n          </div>\n        </div>\n\n        <!-- Input Area -->\n        <div class=\"input-container\">\n          <div class=\"input-actions\">\n            <button class=\"input-btn\" (click)=\"attachFile()\" title=\"Attach File\">\n              <i class=\"icon-paperclip\"></i>\n            </button>\n            <button class=\"input-btn\" (click)=\"captureScreenshot()\" title=\"Screenshot\">\n              <i class=\"icon-camera\"></i>\n            </button>\n            <button class=\"input-btn\" (click)=\"insertEmoji()\" title=\"Emoji\">\n              <i class=\"icon-smile\"></i>\n            </button>\n          </div>\n          \n          <div class=\"input-wrapper\">\n            <textarea\n              #messageInput\n              [(ngModel)]=\"messageText\"\n              (input)=\"onMessageInput($event)\"\n              (keydown)=\"onKeyDown($event)\"\n              (focus)=\"onInputFocus()\"\n              (blur)=\"onInputBlur()\"\n              placeholder=\"Type a message... (@ to mention, : for emoji)\"\n              rows=\"1\"\n              class=\"message-textarea\"\n              [style.height]=\"textareaHeight + 'px'\"></textarea>\n          </div>\n          \n          <div class=\"send-actions\">\n            <button \n              class=\"send-btn\"\n              [disabled]=\"!canSendMessage()\"\n              (click)=\"sendMessage()\"\n              title=\"Send Message\">\n              <i class=\"icon-send\"></i>\n            </button>\n          </div>\n        </div>\n      </div>\n\n      <!-- File Upload Progress -->\n      <div class=\"upload-progress\" *ngIf=\"uploadProgress() > 0 && uploadProgress() < 100\">\n        <div class=\"progress-bar\">\n          <div class=\"progress-fill\" [style.width]=\"uploadProgress() + '%'\"></div>\n        </div>\n        <span class=\"progress-text\">Uploading... {{ uploadProgress() }}%</span>\n      </div>\n    </div>\n\n    <!-- Hidden file input -->\n    <input \n      #fileInput \n      type=\"file\" \n      multiple \n      (change)=\"handleFileSelection($event)\"\n      style=\"display: none;\">\n  `,\n  styleUrls: ['./real-time-messaging.component.scss'],\n  animations: [\n    // Add slide animations here\n  ]\n})\nexport class RealTimeMessagingComponent implements OnInit, OnDestroy {\n  @ViewChild('messagesContainer') messagesContainer!: ElementRef;\n  @ViewChild('messageInput') messageInput!: ElementRef;\n  @ViewChild('fileInput') fileInput!: ElementRef;\n\n  // Inputs\n  roomId = input.required<string>();\n  roomName = input<string>('Collaboration Room');\n  participantCount = input<number>(0);\n  currentUserId = input.required<string>();\n\n  private destroy$ = new Subject<void>();\n  private typingSubject = new Subject<string>();\n  \n  // Services\n  private webSocketService = inject(WebSocketService);\n  private collaborationService = inject(CollaborationService);\n  private presenceService = inject(PresenceService);\n  private notificationService = inject(NotificationService);\n\n  // State signals\n  messages = signal<Message[]>([]);\n  typingUsers = signal<TypingUser[]>([]);\n  activeThread = signal<MessageThread | null>(null);\n  replyingTo = signal<Message | null>(null);\n  showMentions = signal<boolean>(false);\n  showThreads = signal<boolean>(false);\n  unreadMentions = signal<number>(0);\n  highlightedMessageId = signal<string | null>(null);\n  uploadProgress = signal<number>(0);\n  \n  // Input state\n  messageText = '';\n  textareaHeight = 40;\n  showMentionsDropdown = signal<boolean>(false);\n  mentionQuery = signal<string>('');\n  selectedMentionIndex = signal<number>(0);\n  \n  // Available mentions (would come from service in real app)\n  availableMentions = signal<UserMention[]>([\n    {\n      userId: 'user1',\n      username: 'sarah.chen',\n      displayName: 'Sarah Chen',\n      avatar: '/assets/avatars/sarah.jpg',\n      role: 'HR Manager'\n    },\n    {\n      userId: 'user2',\n      username: 'mike.johnson',\n      displayName: 'Mike Johnson',\n      avatar: '/assets/avatars/mike.jpg',\n      role: 'Recruiter'\n    },\n    {\n      userId: 'user3',\n      username: 'emma.wilson',\n      displayName: 'Emma Wilson',\n      avatar: '/assets/avatars/emma.jpg',\n      role: 'Interviewer'\n    }\n  ]);\n\n  // Computed properties\n  displayedMessages = computed(() => {\n    const allMessages = this.messages();\n    return allMessages.filter(msg => !msg.isDeleted);\n  });\n\n  filteredMentions = computed(() => {\n    const query = this.mentionQuery().toLowerCase();\n    if (!query) return [];\n    \n    return this.availableMentions().filter(user => \n      user.username.toLowerCase().includes(query) ||\n      user.displayName.toLowerCase().includes(query)\n    ).slice(0, 5);\n  });\n\n  ngOnInit() {\n    this.initializeMessaging();\n    this.setupTypingIndicator();\n    this.loadInitialMessages();\n  }\n\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n\n  private initializeMessaging() {\n    // Connect to WebSocket for real-time messaging\n    this.webSocketService.connect(this.roomId())\n      .pipe(takeUntil(this.destroy$))\n      .subscribe(message => {\n        this.handleWebSocketMessage(message);\n      });\n  }\n\n  private setupTypingIndicator() {\n    this.typingSubject\n      .pipe(\n        debounceTime(300),\n        distinctUntilChanged(),\n        takeUntil(this.destroy$)\n      )\n      .subscribe(text => {\n        if (text.trim()) {\n          this.sendTypingStart();\n        } else {\n          this.sendTypingStop();\n        }\n      });\n  }\n\n  private async loadInitialMessages() {\n    try {\n      // Load recent messages\n      const messages = await this.collaborationService.getRoomMessages(this.roomId(), 50);\n      this.messages.set(messages);\n      this.scrollToBottom();\n    } catch (error) {\n      console.error('Failed to load messages:', error);\n    }\n  }\n\n  private handleWebSocketMessage(wsMessage: any) {\n    switch (wsMessage.type) {\n      case 'message':\n        this.addMessage(wsMessage.data);\n        break;\n      case 'typing_start':\n        this.addTypingUser(wsMessage.data);\n        break;\n      case 'typing_stop':\n        this.removeTypingUser(wsMessage.data.userId);\n        break;\n      case 'message_reaction':\n        this.updateMessageReaction(wsMessage.data);\n        break;\n      case 'message_edit':\n        this.updateMessage(wsMessage.data);\n        break;\n      case 'message_delete':\n        this.deleteMessageFromList(wsMessage.data.messageId);\n        break;\n    }\n  }\n\n  // Message handling methods\n  async sendMessage() {\n    if (!this.canSendMessage()) return;\n\n    const content = this.messageText.trim();\n    const mentions = this.extractMentions(content);\n    const replyTo = this.replyingTo();\n\n    try {\n      const message = await this.collaborationService.sendMessage(this.roomId(), {\n        type: 'text',\n        content,\n        authorId: this.currentUserId(),\n        authorName: 'Current User', // Would come from user service\n        mentions,\n        replyToId: replyTo?.id,\n      });\n\n      this.addMessage(message);\n      this.messageText = '';\n      this.replyingTo.set(null);\n      this.textareaHeight = 40;\n      this.scrollToBottom();\n      this.sendTypingStop();\n    } catch (error) {\n      console.error('Failed to send message:', error);\n    }\n  }\n\n  private addMessage(message: Message) {\n    const currentMessages = this.messages();\n    const exists = currentMessages.some(m => m.id === message.id);\n    \n    if (!exists) {\n      this.messages.set([...currentMessages, message]);\n      setTimeout(() => this.scrollToBottom(), 100);\n    }\n  }\n\n  private updateMessage(updatedMessage: Message) {\n    const currentMessages = this.messages();\n    const updatedMessages = currentMessages.map(msg => \n      msg.id === updatedMessage.id ? updatedMessage : msg\n    );\n    this.messages.set(updatedMessages);\n  }\n\n  private deleteMessageFromList(messageId: string) {\n    const currentMessages = this.messages();\n    const updatedMessages = currentMessages.map(msg => \n      msg.id === messageId ? { ...msg, isDeleted: true } : msg\n    );\n    this.messages.set(updatedMessages);\n  }\n\n  // Typing indicator methods\n  onMessageInput(event: any) {\n    const text = event.target.value;\n    this.messageText = text;\n    this.adjustTextareaHeight();\n    this.handleMentionInput(text);\n    this.typingSubject.next(text);\n  }\n\n  private sendTypingStart() {\n    this.webSocketService.sendMessage('typing_start', {\n      roomId: this.roomId(),\n      userId: this.currentUserId(),\n      username: 'Current User'\n    });\n  }\n\n  private sendTypingStop() {\n    this.webSocketService.sendMessage('typing_stop', {\n      roomId: this.roomId(),\n      userId: this.currentUserId()\n    });\n  }\n\n  private addTypingUser(user: TypingUser) {\n    const currentTyping = this.typingUsers();\n    const exists = currentTyping.some(u => u.userId === user.userId);\n    \n    if (!exists) {\n      this.typingUsers.set([...currentTyping, user]);\n      \n      // Auto-remove after 5 seconds\n      setTimeout(() => {\n        this.removeTypingUser(user.userId);\n      }, 5000);\n    }\n  }\n\n  private removeTypingUser(userId: string) {\n    const currentTyping = this.typingUsers();\n    const filtered = currentTyping.filter(u => u.userId !== userId);\n    this.typingUsers.set(filtered);\n  }\n\n  // Mention handling\n  private handleMentionInput(text: string) {\n    const cursorPosition = this.messageInput.nativeElement.selectionStart;\n    const textBeforeCursor = text.substring(0, cursorPosition);\n    const mentionMatch = textBeforeCursor.match(/@(\\w*)$/);\n    \n    if (mentionMatch) {\n      const query = mentionMatch[1];\n      this.mentionQuery.set(query);\n      this.showMentionsDropdown.set(true);\n      this.selectedMentionIndex.set(0);\n    } else {\n      this.showMentionsDropdown.set(false);\n      this.mentionQuery.set('');\n    }\n  }\n\n  insertMention(mention: UserMention) {\n    const textarea = this.messageInput.nativeElement;\n    const cursorPosition = textarea.selectionStart;\n    const text = this.messageText;\n    const textBeforeCursor = text.substring(0, cursorPosition);\n    const textAfterCursor = text.substring(cursorPosition);\n    \n    // Find the @ symbol position\n    const mentionStart = textBeforeCursor.lastIndexOf('@');\n    const beforeMention = text.substring(0, mentionStart);\n    \n    const mentionText = `@${mention.username} `;\n    const newText = beforeMention + mentionText + textAfterCursor;\n    const newCursorPosition = beforeMention.length + mentionText.length;\n    \n    this.messageText = newText;\n    this.showMentionsDropdown.set(false);\n    \n    // Set cursor position after mention\n    setTimeout(() => {\n      textarea.focus();\n      textarea.setSelectionRange(newCursorPosition, newCursorPosition);\n    });\n  }\n\n  private extractMentions(text: string): string[] {\n    const mentionRegex = /@(\\w+)/g;\n    const mentions: string[] = [];\n    let match;\n    \n    while ((match = mentionRegex.exec(text)) !== null) {\n      const username = match[1];\n      const user = this.availableMentions().find(u => u.username === username);\n      if (user) {\n        mentions.push(user.userId);\n      }\n    }\n    \n    return mentions;\n  }\n\n  // Keyboard handling\n  onKeyDown(event: KeyboardEvent) {\n    if (event.key === 'Enter' && !event.shiftKey) {\n      event.preventDefault();\n      \n      if (this.showMentionsDropdown() && this.filteredMentions().length > 0) {\n        const selectedMention = this.filteredMentions()[this.selectedMentionIndex()];\n        this.insertMention(selectedMention);\n      } else {\n        this.sendMessage();\n      }\n    } else if (event.key === 'ArrowUp' && this.showMentionsDropdown()) {\n      event.preventDefault();\n      const currentIndex = this.selectedMentionIndex();\n      const newIndex = currentIndex > 0 ? currentIndex - 1 : this.filteredMentions().length - 1;\n      this.selectedMentionIndex.set(newIndex);\n    } else if (event.key === 'ArrowDown' && this.showMentionsDropdown()) {\n      event.preventDefault();\n      const currentIndex = this.selectedMentionIndex();\n      const newIndex = currentIndex < this.filteredMentions().length - 1 ? currentIndex + 1 : 0;\n      this.selectedMentionIndex.set(newIndex);\n    } else if (event.key === 'Escape') {\n      this.showMentionsDropdown.set(false);\n      this.cancelReply();\n    }\n  }\n\n  onInputFocus() {\n    // Mark messages as read when user focuses input\n    this.markMessagesAsRead();\n  }\n\n  onInputBlur() {\n    // Stop typing indicator when input loses focus\n    setTimeout(() => this.sendTypingStop(), 1000);\n  }\n\n  // Message actions\n  replyToMessage(message: Message) {\n    this.replyingTo.set(message);\n    this.messageInput.nativeElement.focus();\n  }\n\n  cancelReply() {\n    this.replyingTo.set(null);\n  }\n\n  startThread(message: Message) {\n    // Create or show thread for this message\n    const thread: MessageThread = {\n      id: `thread-${message.id}`,\n      parentMessageId: message.id,\n      messages: [],\n      participantCount: 1,\n      lastActivity: new Date()\n    };\n    \n    this.activeThread.set(thread);\n  }\n\n  closeThread() {\n    this.activeThread.set(null);\n  }\n\n  async toggleReaction(messageId: string, emoji: string) {\n    try {\n      // Toggle reaction logic\n      const message = this.messages().find(m => m.id === messageId);\n      if (!message) return;\n      \n      const existingReaction = message.reactions.find(\n        r => r.emoji === emoji && r.userId === this.currentUserId()\n      );\n      \n      if (existingReaction) {\n        // Remove reaction\n        message.reactions = message.reactions.filter(r => r !== existingReaction);\n      } else {\n        // Add reaction\n        message.reactions.push({\n          emoji,\n          userId: this.currentUserId(),\n          username: 'Current User',\n          timestamp: new Date()\n        });\n      }\n      \n      this.updateMessage(message);\n      \n      // Send to other clients\n      this.webSocketService.sendMessage('message_reaction', {\n        messageId,\n        emoji,\n        action: existingReaction ? 'remove' : 'add',\n        userId: this.currentUserId()\n      });\n    } catch (error) {\n      console.error('Failed to toggle reaction:', error);\n    }\n  }\n\n  editMessage(message: Message) {\n    // Implement message editing\n    console.log('Editing message:', message.id);\n  }\n\n  async deleteMessage(messageId: string) {\n    if (!confirm('Are you sure you want to delete this message?')) return;\n    \n    try {\n      this.deleteMessageFromList(messageId);\n      \n      // Send delete to other clients\n      this.webSocketService.sendMessage('message_delete', {\n        messageId,\n        userId: this.currentUserId()\n      });\n    } catch (error) {\n      console.error('Failed to delete message:', error);\n    }\n  }\n\n  // File handling\n  attachFile() {\n    this.fileInput.nativeElement.click();\n  }\n\n  handleFileSelection(event: any) {\n    const files = event.target.files;\n    if (files && files.length > 0) {\n      this.uploadFiles(Array.from(files));\n    }\n  }\n\n  private async uploadFiles(files: File[]) {\n    for (const file of files) {\n      await this.uploadSingleFile(file);\n    }\n  }\n\n  private async uploadSingleFile(file: File): Promise<void> {\n    try {\n      this.uploadProgress.set(0);\n      \n      // Simulate file upload progress\n      const progressInterval = setInterval(() => {\n        const current = this.uploadProgress();\n        if (current < 95) {\n          this.uploadProgress.set(current + 5);\n        }\n      }, 100);\n      \n      // In real implementation, upload to file service\n      await new Promise(resolve => setTimeout(resolve, 2000));\n      \n      clearInterval(progressInterval);\n      this.uploadProgress.set(100);\n      \n      // Create message with attachment\n      const attachment: MessageAttachment = {\n        id: this.generateId(),\n        filename: file.name,\n        mimetype: file.type,\n        size: file.size,\n        url: URL.createObjectURL(file), // Temporary URL\n        thumbnailUrl: file.type.startsWith('image/') ? URL.createObjectURL(file) : undefined\n      };\n      \n      const message = await this.collaborationService.sendMessage(this.roomId(), {\n        type: 'file',\n        content: `Shared a file: ${file.name}`,\n        authorId: this.currentUserId(),\n        authorName: 'Current User',\n        attachments: [attachment]\n      });\n      \n      this.addMessage(message);\n      \n      setTimeout(() => this.uploadProgress.set(0), 1000);\n    } catch (error) {\n      console.error('Failed to upload file:', error);\n      this.uploadProgress.set(0);\n    }\n  }\n\n  // Utility methods\n  private adjustTextareaHeight() {\n    const textarea = this.messageInput.nativeElement;\n    textarea.style.height = 'auto';\n    const newHeight = Math.min(Math.max(textarea.scrollHeight, 40), 120);\n    this.textareaHeight = newHeight;\n    textarea.style.height = newHeight + 'px';\n  }\n\n  private scrollToBottom() {\n    if (this.messagesContainer) {\n      const container = this.messagesContainer.nativeElement;\n      container.scrollTop = container.scrollHeight;\n    }\n  }\n\n  private markMessagesAsRead() {\n    // Mark recent messages as read\n    const unreadMessages = this.messages().filter(m => \n      m.authorId !== this.currentUserId() && \n      m.mentions.includes(this.currentUserId())\n    );\n    \n    if (unreadMessages.length > 0) {\n      this.unreadMentions.set(0);\n    }\n  }\n\n  formatMessageContent(content: string): string {\n    // Format mentions, links, code blocks, etc.\n    let formatted = content;\n    \n    // Format mentions\n    formatted = formatted.replace(/@(\\w+)/g, '<span class=\"mention\">@$1</span>');\n    \n    // Format links\n    formatted = formatted.replace(\n      /(https?:\\/\\/[^\\s]+)/g, \n      '<a href=\"$1\" target=\"_blank\" rel=\"noopener noreferrer\">$1</a>'\n    );\n    \n    // Format code blocks\n    formatted = formatted.replace(/`([^`]+)`/g, '<code>$1</code>');\n    \n    return formatted;\n  }\n\n  isConsecutiveMessage(message: Message): boolean {\n    const messages = this.messages();\n    const index = messages.findIndex(m => m.id === message.id);\n    \n    if (index === 0) return false;\n    \n    const previousMessage = messages[index - 1];\n    const timeDiff = message.timestamp.getTime() - previousMessage.timestamp.getTime();\n    \n    return (\n      previousMessage.authorId === message.authorId &&\n      timeDiff < 5 * 60 * 1000 && // 5 minutes\n      !previousMessage.isDeleted\n    );\n  }\n\n  canEditMessage(message: Message): boolean {\n    return (\n      message.authorId === this.currentUserId() &&\n      !message.isDeleted &&\n      (new Date().getTime() - message.timestamp.getTime()) < 15 * 60 * 1000 // 15 minutes\n    );\n  }\n\n  canDeleteMessage(message: Message): boolean {\n    return (\n      message.authorId === this.currentUserId() ||\n      this.hasModeratorPermissions()\n    ) && !message.isDeleted;\n  }\n\n  canSendMessage(): boolean {\n    return this.messageText.trim().length > 0;\n  }\n\n  private hasModeratorPermissions(): boolean {\n    // Check if current user has moderator permissions\n    return false; // Would be determined by user role\n  }\n\n  getGroupedReactions(reactions: MessageReaction[]): any[] {\n    const grouped = reactions.reduce((acc, reaction) => {\n      if (!acc[reaction.emoji]) {\n        acc[reaction.emoji] = {\n          emoji: reaction.emoji,\n          users: [],\n          count: 0\n        };\n      }\n      acc[reaction.emoji].users.push({\n        userId: reaction.userId,\n        username: reaction.username\n      });\n      acc[reaction.emoji].count++;\n      return acc;\n    }, {} as any);\n    \n    return Object.values(grouped);\n  }\n\n  hasUserReacted(reaction: any, userId: string): boolean {\n    return reaction.users.some((user: any) => user.userId === userId);\n  }\n\n  getReactionTooltip(reaction: any): string {\n    const usernames = reaction.users.map((user: any) => user.username).join(', ');\n    return `${usernames} reacted with ${reaction.emoji}`;\n  }\n\n  getContextType(contextData: any): string {\n    if (contextData.candidateId) return 'candidate';\n    if (contextData.documentId) return 'document';\n    if (contextData.voteId) return 'vote';\n    return 'unknown';\n  }\n\n  isImageAttachment(attachment: MessageAttachment): boolean {\n    return attachment.mimetype.startsWith('image/');\n  }\n\n  getAttachmentClass(mimetype: string): string {\n    if (mimetype.startsWith('image/')) return 'image-attachment';\n    if (mimetype.startsWith('video/')) return 'video-attachment';\n    if (mimetype.includes('pdf')) return 'pdf-attachment';\n    return 'file-attachment';\n  }\n\n  formatFileSize(bytes: number): string {\n    if (bytes === 0) return '0 Bytes';\n    \n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    \n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n\n  downloadAttachment(attachment: MessageAttachment) {\n    const link = document.createElement('a');\n    link.href = attachment.url;\n    link.download = attachment.filename;\n    link.click();\n  }\n\n  private generateId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  // Action methods\n  toggleMentions() {\n    this.showMentions.set(!this.showMentions());\n  }\n\n  toggleThreads() {\n    this.showThreads.set(!this.showThreads());\n  }\n\n  shareScreen() {\n    console.log('Starting screen share');\n    // Implement screen sharing\n  }\n\n  startCall() {\n    console.log('Starting call');\n    // Implement video call\n  }\n\n  addReaction(messageId: string) {\n    // Show emoji picker\n    console.log('Adding reaction to message:', messageId);\n  }\n\n  showEmojiPicker(messageId: string) {\n    // Show emoji picker for message\n    console.log('Showing emoji picker for message:', messageId);\n  }\n\n  captureScreenshot() {\n    console.log('Capturing screenshot');\n    // Implement screenshot capture\n  }\n\n  insertEmoji() {\n    console.log('Inserting emoji');\n    // Show emoji picker\n  }\n\n  // Track by functions\n  trackByMessageId(index: number, message: Message): string {\n    return message.id;\n  }\n\n  private updateMessageReaction(data: any) {\n    const message = this.messages().find(m => m.id === data.messageId);\n    if (!message) return;\n    \n    if (data.action === 'add') {\n      message.reactions.push({\n        emoji: data.emoji,\n        userId: data.userId,\n        username: data.username || 'Unknown',\n        timestamp: new Date()\n      });\n    } else {\n      message.reactions = message.reactions.filter(\n        r => !(r.emoji === data.emoji && r.userId === data.userId)\n      );\n    }\n    \n    this.updateMessage(message);\n  }\n}