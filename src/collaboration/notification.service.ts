import { Injectable, Logger } from '@nestjs/common';\nimport { CacheService } from '../cache/cache.service';\n\nexport interface Notification {\n  id: string;\n  userId: string;\n  type: 'mention' | 'comment' | 'vote' | 'decision' | 'message' | 'system' | 'urgent';\n  title: string;\n  content: string;\n  priority: 'low' | 'medium' | 'high' | 'urgent';\n  channels: NotificationChannel[];\n  context?: {\n    roomId?: string;\n    messageId?: string;\n    decisionId?: string;\n    candidateId?: string;\n    jobId?: string;\n    documentId?: string;\n  };\n  actions?: NotificationAction[];\n  metadata?: {\n    sender?: {\n      userId: string;\n      username: string;\n      avatar?: string;\n    };\n    tags?: string[];\n    customData?: Record<string, any>;\n  };\n  createdAt: Date;\n  scheduledFor?: Date;\n  expiresAt?: Date;\n  status: 'pending' | 'sent' | 'delivered' | 'read' | 'failed' | 'expired';\n  deliveryAttempts: DeliveryAttempt[];\n}\n\nexport interface NotificationChannel {\n  type: 'push' | 'email' | 'sms' | 'webhook' | 'in_app' | 'desktop';\n  enabled: boolean;\n  config?: {\n    email?: { template?: string; subject?: string };\n    push?: { title?: string; icon?: string; badge?: string };\n    sms?: { template?: string };\n    webhook?: { url: string; headers?: Record<string, string> };\n  };\n}\n\nexport interface NotificationAction {\n  id: string;\n  label: string;\n  type: 'button' | 'link' | 'inline_reply';\n  action: string; // URL or action identifier\n  style?: 'primary' | 'secondary' | 'danger';\n  requiresAuth?: boolean;\n}\n\nexport interface DeliveryAttempt {\n  channel: NotificationChannel['type'];\n  timestamp: Date;\n  status: 'success' | 'failed' | 'retry';\n  error?: string;\n  responseTime?: number;\n}\n\nexport interface UserNotificationPreferences {\n  userId: string;\n  channels: {\n    push: {\n      enabled: boolean;\n      quietHours?: { start: string; end: string; timezone: string };\n      topics: {\n        mentions: boolean;\n        comments: boolean;\n        votes: boolean;\n        decisions: boolean;\n        messages: boolean;\n        urgent: boolean;\n      };\n    };\n    email: {\n      enabled: boolean;\n      frequency: 'immediate' | 'hourly' | 'daily' | 'weekly';\n      digest: boolean;\n      topics: {\n        mentions: boolean;\n        comments: boolean;\n        votes: boolean;\n        decisions: boolean;\n        messages: boolean;\n        urgent: boolean;\n      };\n    };\n    sms: {\n      enabled: boolean;\n      urgentOnly: boolean;\n      phone?: string;\n    };\n    inApp: {\n      enabled: boolean;\n      showDesktopNotifications: boolean;\n      sound: boolean;\n      topics: {\n        mentions: boolean;\n        comments: boolean;\n        votes: boolean;\n        decisions: boolean;\n        messages: boolean;\n        urgent: boolean;\n      };\n    };\n  };\n  doNotDisturb?: {\n    enabled: boolean;\n    schedule?: {\n      start: string;\n      end: string;\n      timezone: string;\n      days: string[]; // ['monday', 'tuesday', ...]\n    };\n    exceptions: string[]; // notification types that bypass DND\n  };\n  updatedAt: Date;\n}\n\nexport interface NotificationBatch {\n  id: string;\n  userId: string;\n  type: 'digest' | 'summary';\n  period: 'hourly' | 'daily' | 'weekly';\n  notifications: Notification[];\n  createdAt: Date;\n  sentAt?: Date;\n}\n\nexport interface NotificationTemplate {\n  id: string;\n  name: string;\n  type: Notification['type'];\n  channels: {\n    email?: {\n      subject: string;\n      html: string;\n      text: string;\n    };\n    push?: {\n      title: string;\n      body: string;\n      icon?: string;\n    };\n    sms?: {\n      message: string;\n    };\n    inApp?: {\n      title: string;\n      content: string;\n      icon?: string;\n    };\n  };\n  variables: string[]; // List of template variables\n  active: boolean;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n@Injectable()\nexport class NotificationService {\n  private readonly logger = new Logger(NotificationService.name);\n  private readonly NOTIFICATION_TTL = 30 * 24 * 60 * 60 * 1000; // 30 days\n  private readonly BATCH_SIZE = 100;\n  private readonly RETRY_ATTEMPTS = 3;\n  private readonly RETRY_DELAY = 5000; // 5 seconds\n\n  constructor(private readonly cacheService: CacheService) {\n    this.startBatchProcessor();\n  }\n\n  /**\n   * Send a notification to a user\n   */\n  async sendNotification(notification: Partial<Notification>): Promise<string> {\n    const notificationId = this.generateId();\n    \n    const fullNotification: Notification = {\n      id: notificationId,\n      userId: notification.userId!,\n      type: notification.type || 'message',\n      title: notification.title || '',\n      content: notification.content || '',\n      priority: notification.priority || 'medium',\n      channels: notification.channels || await this.getUserDefaultChannels(notification.userId!),\n      context: notification.context,\n      actions: notification.actions,\n      metadata: notification.metadata,\n      createdAt: new Date(),\n      scheduledFor: notification.scheduledFor,\n      expiresAt: notification.expiresAt || new Date(Date.now() + this.NOTIFICATION_TTL),\n      status: 'pending',\n      deliveryAttempts: [],\n    };\n\n    // Store notification\n    await this.cacheService.set(\n      `notification:${notificationId}`, \n      fullNotification, \n      this.NOTIFICATION_TTL\n    );\n\n    // Add to user's notification queue\n    await this.addToUserQueue(notification.userId!, notificationId);\n\n    // Process immediately if not scheduled\n    if (!notification.scheduledFor) {\n      await this.processNotification(fullNotification);\n    } else {\n      await this.scheduleNotification(fullNotification);\n    }\n\n    this.logger.log(`Notification ${notificationId} created for user ${notification.userId}`);\n    return notificationId;\n  }\n\n  /**\n   * Send bulk notifications\n   */\n  async sendBulkNotifications(notifications: Partial<Notification>[]): Promise<string[]> {\n    const notificationIds: string[] = [];\n    \n    for (const notification of notifications) {\n      try {\n        const id = await this.sendNotification(notification);\n        notificationIds.push(id);\n      } catch (error) {\n        this.logger.error(`Failed to send bulk notification: ${error.message}`);\n      }\n    }\n    \n    return notificationIds;\n  }\n\n  /**\n   * Get user notifications\n   */\n  async getUserNotifications(\n    userId: string, \n    options: {\n      limit?: number;\n      offset?: number;\n      unreadOnly?: boolean;\n      types?: Notification['type'][];\n    } = {}\n  ): Promise<Notification[]> {\n    const queueKey = `user:${userId}:notifications`;\n    const notificationIds = await this.cacheService.get<string[]>(queueKey) || [];\n    \n    const { limit = 50, offset = 0, unreadOnly = false, types } = options;\n    \n    const notifications: Notification[] = [];\n    let processed = 0;\n    let skipped = 0;\n    \n    for (const notificationId of notificationIds.reverse()) { // Most recent first\n      if (skipped < offset) {\n        skipped++;\n        continue;\n      }\n      \n      if (processed >= limit) break;\n      \n      const notification = await this.cacheService.get<Notification>(`notification:${notificationId}`);\n      if (!notification) continue;\n      \n      // Apply filters\n      if (unreadOnly && notification.status === 'read') continue;\n      if (types && !types.includes(notification.type)) continue;\n      \n      notifications.push(notification);\n      processed++;\n    }\n    \n    return notifications;\n  }\n\n  /**\n   * Mark notification as read\n   */\n  async markAsRead(notificationId: string, userId: string): Promise<boolean> {\n    const notification = await this.cacheService.get<Notification>(`notification:${notificationId}`);\n    \n    if (!notification || notification.userId !== userId) {\n      return false;\n    }\n    \n    notification.status = 'read';\n    await this.cacheService.set(`notification:${notificationId}`, notification, this.NOTIFICATION_TTL);\n    \n    this.logger.debug(`Notification ${notificationId} marked as read by user ${userId}`);\n    return true;\n  }\n\n  /**\n   * Mark all notifications as read for a user\n   */\n  async markAllAsRead(userId: string): Promise<number> {\n    const notifications = await this.getUserNotifications(userId, { unreadOnly: true, limit: 1000 });\n    let marked = 0;\n    \n    for (const notification of notifications) {\n      if (await this.markAsRead(notification.id, userId)) {\n        marked++;\n      }\n    }\n    \n    this.logger.log(`Marked ${marked} notifications as read for user ${userId}`);\n    return marked;\n  }\n\n  /**\n   * Delete notification\n   */\n  async deleteNotification(notificationId: string, userId: string): Promise<boolean> {\n    const notification = await this.cacheService.get<Notification>(`notification:${notificationId}`);\n    \n    if (!notification || notification.userId !== userId) {\n      return false;\n    }\n    \n    // Remove from cache\n    await this.cacheService.del(`notification:${notificationId}`);\n    \n    // Remove from user queue\n    await this.removeFromUserQueue(userId, notificationId);\n    \n    this.logger.debug(`Notification ${notificationId} deleted for user ${userId}`);\n    return true;\n  }\n\n  /**\n   * Get user notification preferences\n   */\n  async getUserPreferences(userId: string): Promise<UserNotificationPreferences> {\n    const prefsKey = `user:${userId}:notification_preferences`;\n    const existing = await this.cacheService.get<UserNotificationPreferences>(prefsKey);\n    \n    if (existing) {\n      return existing;\n    }\n    \n    // Return default preferences\n    const defaultPrefs: UserNotificationPreferences = {\n      userId,\n      channels: {\n        push: {\n          enabled: true,\n          topics: {\n            mentions: true,\n            comments: true,\n            votes: true,\n            decisions: true,\n            messages: false,\n            urgent: true,\n          },\n        },\n        email: {\n          enabled: true,\n          frequency: 'immediate',\n          digest: false,\n          topics: {\n            mentions: true,\n            comments: false,\n            votes: true,\n            decisions: true,\n            messages: false,\n            urgent: true,\n          },\n        },\n        sms: {\n          enabled: false,\n          urgentOnly: true,\n        },\n        inApp: {\n          enabled: true,\n          showDesktopNotifications: true,\n          sound: true,\n          topics: {\n            mentions: true,\n            comments: true,\n            votes: true,\n            decisions: true,\n            messages: true,\n            urgent: true,\n          },\n        },\n      },\n      doNotDisturb: {\n        enabled: false,\n        exceptions: ['urgent'],\n      },\n      updatedAt: new Date(),\n    };\n    \n    await this.updateUserPreferences(userId, defaultPrefs);\n    return defaultPrefs;\n  }\n\n  /**\n   * Update user notification preferences\n   */\n  async updateUserPreferences(\n    userId: string, \n    preferences: Partial<UserNotificationPreferences>\n  ): Promise<UserNotificationPreferences> {\n    const existing = await this.getUserPreferences(userId);\n    \n    const updated: UserNotificationPreferences = {\n      ...existing,\n      ...preferences,\n      userId, // Ensure userId is preserved\n      updatedAt: new Date(),\n    };\n    \n    const prefsKey = `user:${userId}:notification_preferences`;\n    await this.cacheService.set(prefsKey, updated, this.NOTIFICATION_TTL);\n    \n    this.logger.log(`Updated notification preferences for user ${userId}`);\n    return updated;\n  }\n\n  /**\n   * Get notification statistics for a user\n   */\n  async getUserNotificationStats(userId: string): Promise<{\n    total: number;\n    unread: number;\n    byType: Record<string, number>;\n    byPriority: Record<string, number>;\n    recent: number; // Last 24 hours\n  }> {\n    const notifications = await this.getUserNotifications(userId, { limit: 1000 });\n    \n    const stats = {\n      total: notifications.length,\n      unread: notifications.filter(n => n.status !== 'read').length,\n      byType: {} as Record<string, number>,\n      byPriority: {} as Record<string, number>,\n      recent: 0,\n    };\n    \n    const dayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);\n    \n    notifications.forEach(notification => {\n      // Count by type\n      stats.byType[notification.type] = (stats.byType[notification.type] || 0) + 1;\n      \n      // Count by priority\n      stats.byPriority[notification.priority] = (stats.byPriority[notification.priority] || 0) + 1;\n      \n      // Count recent\n      if (notification.createdAt > dayAgo) {\n        stats.recent++;\n      }\n    });\n    \n    return stats;\n  }\n\n  /**\n   * Create notification template\n   */\n  async createTemplate(template: Partial<NotificationTemplate>): Promise<NotificationTemplate> {\n    const templateId = this.generateId();\n    \n    const fullTemplate: NotificationTemplate = {\n      id: templateId,\n      name: template.name || 'Untitled Template',\n      type: template.type || 'message',\n      channels: template.channels || {},\n      variables: template.variables || [],\n      active: template.active !== false,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n    \n    await this.cacheService.set(`notification_template:${templateId}`, fullTemplate, this.NOTIFICATION_TTL);\n    \n    this.logger.log(`Created notification template ${templateId}`);\n    return fullTemplate;\n  }\n\n  /**\n   * Send notification using template\n   */\n  async sendFromTemplate(\n    templateId: string, \n    userId: string, \n    variables: Record<string, any> = {},\n    overrides: Partial<Notification> = {}\n  ): Promise<string> {\n    const template = await this.cacheService.get<NotificationTemplate>(`notification_template:${templateId}`);\n    \n    if (!template || !template.active) {\n      throw new Error(`Template ${templateId} not found or inactive`);\n    }\n    \n    // Process template variables\n    const processedTemplate = this.processTemplate(template, variables);\n    \n    const notification: Partial<Notification> = {\n      userId,\n      type: template.type,\n      title: processedTemplate.channels.inApp?.title || '',\n      content: processedTemplate.channels.inApp?.content || '',\n      ...overrides,\n    };\n    \n    return await this.sendNotification(notification);\n  }\n\n  /**\n   * Private helper methods\n   */\n  private generateId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private async addToUserQueue(userId: string, notificationId: string): Promise<void> {\n    const queueKey = `user:${userId}:notifications`;\n    const queue = await this.cacheService.get<string[]>(queueKey) || [];\n    \n    queue.push(notificationId);\n    \n    // Keep only last 1000 notifications\n    if (queue.length > 1000) {\n      queue.splice(0, queue.length - 1000);\n    }\n    \n    await this.cacheService.set(queueKey, queue, this.NOTIFICATION_TTL);\n  }\n\n  private async removeFromUserQueue(userId: string, notificationId: string): Promise<void> {\n    const queueKey = `user:${userId}:notifications`;\n    const queue = await this.cacheService.get<string[]>(queueKey) || [];\n    \n    const index = queue.indexOf(notificationId);\n    if (index > -1) {\n      queue.splice(index, 1);\n      await this.cacheService.set(queueKey, queue, this.NOTIFICATION_TTL);\n    }\n  }\n\n  private async getUserDefaultChannels(userId: string): Promise<NotificationChannel[]> {\n    const preferences = await this.getUserPreferences(userId);\n    \n    const channels: NotificationChannel[] = [];\n    \n    if (preferences.channels.inApp.enabled) {\n      channels.push({ type: 'in_app', enabled: true });\n    }\n    \n    if (preferences.channels.push.enabled) {\n      channels.push({ type: 'push', enabled: true });\n    }\n    \n    if (preferences.channels.email.enabled) {\n      channels.push({ type: 'email', enabled: true });\n    }\n    \n    return channels;\n  }\n\n  private async processNotification(notification: Notification): Promise<void> {\n    const preferences = await this.getUserPreferences(notification.userId);\n    \n    // Check do not disturb\n    if (this.isDoNotDisturbActive(preferences) && !this.bypassesDoNotDisturb(notification, preferences)) {\n      this.logger.debug(`Skipping notification ${notification.id} due to do not disturb`);\n      return;\n    }\n    \n    // Process each enabled channel\n    for (const channel of notification.channels) {\n      if (channel.enabled && this.isChannelEnabled(notification.type, channel.type, preferences)) {\n        await this.deliverToChannel(notification, channel);\n      }\n    }\n  }\n\n  private async deliverToChannel(notification: Notification, channel: NotificationChannel): Promise<void> {\n    const attempt: DeliveryAttempt = {\n      channel: channel.type,\n      timestamp: new Date(),\n      status: 'failed',\n    };\n    \n    const startTime = Date.now();\n    \n    try {\n      switch (channel.type) {\n        case 'in_app':\n          await this.deliverInApp(notification);\n          break;\n        case 'push':\n          await this.deliverPush(notification, channel.config?.push);\n          break;\n        case 'email':\n          await this.deliverEmail(notification, channel.config?.email);\n          break;\n        case 'sms':\n          await this.deliverSMS(notification, channel.config?.sms);\n          break;\n        case 'webhook':\n          await this.deliverWebhook(notification, channel.config?.webhook);\n          break;\n      }\n      \n      attempt.status = 'success';\n      notification.status = 'delivered';\n    } catch (error) {\n      this.logger.error(`Failed to deliver notification ${notification.id} via ${channel.type}: ${error.message}`);\n      attempt.error = error.message;\n      \n      // Retry logic\n      if (notification.deliveryAttempts.filter(a => a.channel === channel.type).length < this.RETRY_ATTEMPTS) {\n        setTimeout(() => {\n          this.deliverToChannel(notification, channel);\n        }, this.RETRY_DELAY);\n      }\n    }\n    \n    attempt.responseTime = Date.now() - startTime;\n    notification.deliveryAttempts.push(attempt);\n    \n    // Update notification in cache\n    await this.cacheService.set(`notification:${notification.id}`, notification, this.NOTIFICATION_TTL);\n  }\n\n  private async deliverInApp(notification: Notification): Promise<void> {\n    // Store for real-time delivery via WebSocket\n    const inAppKey = `user:${notification.userId}:in_app_notifications`;\n    const inAppNotifications = await this.cacheService.get<Notification[]>(inAppKey) || [];\n    \n    inAppNotifications.unshift(notification);\n    \n    // Keep only last 100 in-app notifications\n    if (inAppNotifications.length > 100) {\n      inAppNotifications.splice(100);\n    }\n    \n    await this.cacheService.set(inAppKey, inAppNotifications, this.NOTIFICATION_TTL);\n    \n    this.logger.debug(`Delivered in-app notification ${notification.id}`);\n  }\n\n  private async deliverPush(notification: Notification, config?: any): Promise<void> {\n    // Implement push notification delivery\n    // This would integrate with services like Firebase, OneSignal, etc.\n    this.logger.debug(`Push notification ${notification.id} would be sent here`);\n  }\n\n  private async deliverEmail(notification: Notification, config?: any): Promise<void> {\n    // Implement email delivery\n    // This would integrate with email services like SendGrid, Mailgun, etc.\n    this.logger.debug(`Email notification ${notification.id} would be sent here`);\n  }\n\n  private async deliverSMS(notification: Notification, config?: any): Promise<void> {\n    // Implement SMS delivery\n    // This would integrate with services like Twilio, AWS SNS, etc.\n    this.logger.debug(`SMS notification ${notification.id} would be sent here`);\n  }\n\n  private async deliverWebhook(notification: Notification, config?: any): Promise<void> {\n    // Implement webhook delivery\n    this.logger.debug(`Webhook notification ${notification.id} would be sent here`);\n  }\n\n  private isDoNotDisturbActive(preferences: UserNotificationPreferences): boolean {\n    if (!preferences.doNotDisturb?.enabled || !preferences.doNotDisturb?.schedule) {\n      return false;\n    }\n    \n    const now = new Date();\n    const schedule = preferences.doNotDisturb.schedule;\n    \n    // Simple time-based check (would need more sophisticated timezone handling in production)\n    const currentHour = now.getHours();\n    const startHour = parseInt(schedule.start.split(':')[0]);\n    const endHour = parseInt(schedule.end.split(':')[0]);\n    \n    return currentHour >= startHour && currentHour <= endHour;\n  }\n\n  private bypassesDoNotDisturb(notification: Notification, preferences: UserNotificationPreferences): boolean {\n    return preferences.doNotDisturb?.exceptions?.includes(notification.type) || \n           notification.priority === 'urgent';\n  }\n\n  private isChannelEnabled(\n    notificationType: Notification['type'], \n    channelType: NotificationChannel['type'], \n    preferences: UserNotificationPreferences\n  ): boolean {\n    switch (channelType) {\n      case 'in_app':\n        return preferences.channels.inApp.enabled && \n               preferences.channels.inApp.topics[notificationType as keyof typeof preferences.channels.inApp.topics];\n      case 'push':\n        return preferences.channels.push.enabled && \n               preferences.channels.push.topics[notificationType as keyof typeof preferences.channels.push.topics];\n      case 'email':\n        return preferences.channels.email.enabled && \n               preferences.channels.email.topics[notificationType as keyof typeof preferences.channels.email.topics];\n      case 'sms':\n        return preferences.channels.sms.enabled && \n               (notificationType === 'urgent' || !preferences.channels.sms.urgentOnly);\n      default:\n        return true;\n    }\n  }\n\n  private processTemplate(template: NotificationTemplate, variables: Record<string, any>): NotificationTemplate {\n    // Simple variable substitution\n    const processed = JSON.parse(JSON.stringify(template));\n    \n    const substituteVariables = (text: string): string => {\n      return text.replace(/\\{\\{(\\w+)\\}\\}/g, (match, variable) => {\n        return variables[variable] || match;\n      });\n    };\n    \n    // Process all text fields in channels\n    Object.keys(processed.channels).forEach(channelType => {\n      const channel = processed.channels[channelType];\n      if (channel) {\n        Object.keys(channel).forEach(key => {\n          if (typeof channel[key] === 'string') {\n            channel[key] = substituteVariables(channel[key]);\n          }\n        });\n      }\n    });\n    \n    return processed;\n  }\n\n  private async scheduleNotification(notification: Notification): Promise<void> {\n    // Store in scheduled notifications queue\n    const scheduledKey = 'scheduled_notifications';\n    const scheduled = await this.cacheService.get<string[]>(scheduledKey) || [];\n    scheduled.push(notification.id);\n    await this.cacheService.set(scheduledKey, scheduled, this.NOTIFICATION_TTL);\n    \n    this.logger.debug(`Notification ${notification.id} scheduled for ${notification.scheduledFor}`);\n  }\n\n  private startBatchProcessor(): void {\n    // Process scheduled notifications every minute\n    setInterval(async () => {\n      await this.processScheduledNotifications();\n    }, 60000);\n    \n    // Process email digests every hour\n    setInterval(async () => {\n      await this.processEmailDigests();\n    }, 3600000);\n  }\n\n  private async processScheduledNotifications(): Promise<void> {\n    const scheduledKey = 'scheduled_notifications';\n    const scheduled = await this.cacheService.get<string[]>(scheduledKey) || [];\n    const now = new Date();\n    const toProcess: string[] = [];\n    const remaining: string[] = [];\n    \n    for (const notificationId of scheduled) {\n      const notification = await this.cacheService.get<Notification>(`notification:${notificationId}`);\n      \n      if (!notification) {\n        continue; // Skip if notification no longer exists\n      }\n      \n      if (notification.scheduledFor && notification.scheduledFor <= now) {\n        toProcess.push(notificationId);\n      } else {\n        remaining.push(notificationId);\n      }\n    }\n    \n    // Update scheduled list\n    await this.cacheService.set(scheduledKey, remaining, this.NOTIFICATION_TTL);\n    \n    // Process due notifications\n    for (const notificationId of toProcess) {\n      const notification = await this.cacheService.get<Notification>(`notification:${notificationId}`);\n      if (notification) {\n        await this.processNotification(notification);\n      }\n    }\n    \n    if (toProcess.length > 0) {\n      this.logger.log(`Processed ${toProcess.length} scheduled notifications`);\n    }\n  }\n\n  private async processEmailDigests(): Promise<void> {\n    // Implementation for email digest processing\n    this.logger.debug('Processing email digests...');\n  }\n}